<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Necessary (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Necessary</h1>

<span class="command">theory</span> <span class="name">Necessary</span><br/>
<span class="keyword">imports</span> <a href="Computation.html"><span class="name">Computation</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Necessary</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Computation</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>necessary</span><span> </span><span class="delimiter">=</span><span> </span><span>fnft</span><span class="delimiter">:</span><span> </span><span>fNFT</span><span> </span><span>ninit</span><span> </span><span>n&#948;</span><span> </span><span>naccept</span><span> </span><span>nQ</span><span> </span><span class="delimiter">+</span><span> </span><span>fTDFA</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ninit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a :: finite &#8658; &#39;s &#215; (&#39;b :: finite) list &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>naccept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nQ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;t &#8658; (&#39;a :: finite) Al &#215; (&#39;b :: finite) Al &#8658; &#39;t &#215; bool &#215; bool &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;t &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;t set&quot;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.&#964; = &#964;&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>TDFA</span><span> </span><span>init</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;q (a, b) (q&#39;, b1, b2). &#948; q (b, a) (q&#39;, b2, b1)&quot;</span></span></span><span> </span><span>accept</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>det</span><span> </span><span>finite_Q</span><span> </span><span>init_in_Q</span><span> </span><span>closed</span><span> </span><span>move_left</span><span> </span><span>move_right</span><span> </span><span>no_step</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flip_comp_intro</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233; flip.computation q (bs, as) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flip_comp_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flip.computation q (bs, as) q&#39; &#10233; q &#8605;(as, bs) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(bs, as)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>flip.computation.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flip_comp_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flip.computation q (bs, as) q&#39; &#10231; q &#8605;(as, bs) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>flip_comp_intro</span><span> </span><span>flip_comp_dest</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>flip_outs_Nil_dest</span><span> </span><span class="delimiter">=</span><span> </span><span>flip.outs_Nil_dest</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>flip_comp_eq</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>flip_outs_Cons_dest</span><span> </span><span class="delimiter">=</span><span> </span><span>flip.outs_Cons_dest</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>flip_comp_eq</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>flip_outs_Nil_intro</span><span> </span><span class="delimiter">=</span><span> </span><span>flip.outs_Nil_intro</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>flip_comp_eq</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>flip_outs_Cons_intro</span><span> </span><span class="delimiter">=</span><span> </span><span>flip.outs_Cons_intro</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>flip_comp_eq</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_long</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length w &#8805; n + 1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;v&#39; y z. w = v&#39; @ y # z &#8743; length z = n&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v&#39;</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w = v&#39; @ y # z&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length z &#8805; n&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nat.le_diff_conv2</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_le_eq</span><span> </span><span>add_leD2</span><span> </span><span>id_take_nth_drop</span><span> </span><span>length_drop</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length z &gt; n&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>z&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z&#39; = drop (length z - n) z&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>y&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#39; = z ! (length z - n - 1)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_z&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length z&#39; = n&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>z&#39;_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>split&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w = (v&#39; @ y # (take (length z - n - 1) z)) @ y&#39; # z&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>y&#39;_def</span><span> </span><span>z&#39;_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_diff_Suc</span><span> </span><span>diff_Suc_less</span><span> </span><span>drop_Nil</span><span>
</span><span>          </span><span>id_take_nth_drop</span><span> </span><span>len_z&#39;</span><span> </span><span>length_greater_0_conv</span><span> </span><span>nat_neq_iff</span><span> </span><span>z&#39;_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split&#39;</span><span> </span><span>len_z&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>concat_filter</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs = length xs &#10233; length ns = length xs &#10233;
  concat (map (&#955;(n, (q, bs), (bs&#39;, q&#39;)). bs) (filter (&#955;(n, (q, bs), (bs&#39;, q&#39;)). bs &#8800; [])
  (zip ns (zip qbs xs)))) = concat (map snd qbs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>qbs</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ns</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_induct2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>xs</span><span> </span><span>y</span><span> </span><span>ys</span><span> </span><span>ns</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ns</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>concat_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;n q bs bs&#39; q&#39;. (n, (q, bs), (bs&#39;, q&#39;)) &#8712; set qss&#39; &#10233; length bs &#8804; d) &#10233;
  length (concat (map (&#955;(n, (q, bs), (bs&#39;, q&#39;)). bs) qss&#39;)) &#8804; length qss&#39; * d&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>qss&#39;</span><span class="delimiter">)</span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sorted xs &#10233; distinct xs &#10233; i &lt; j &#10233; j &lt; length xs &#10233; xs ! i &lt; xs ! j&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_le</span><span> </span><span>nth_eq_iff_index_eq</span><span> </span><span>sorted_iff_nth_mono_less</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map2_zip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs = length xs &#10233; length qbs = length ns &#10233;
  qbs = map2 (&#955;n ((q, bs), (bs&#39;, q&#39;)). (q, bs)) ns (zip qbs xs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>qbs</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ns</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_induct2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>xs</span><span> </span><span>y</span><span> </span><span>ys</span><span> </span><span>ns</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ns</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map2_zip&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs = length xs &#10233; length qbs = length ns &#10233;
  xs = map2 (&#955;n ((q, bs), (bs&#39;, q&#39;)). (bs&#39;, q&#39;)) ns (zip qbs xs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>qbs</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ns</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_induct2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>xs</span><span> </span><span>y</span><span> </span><span>ys</span><span> </span><span>ns</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ns</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_one</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &lt; length xs &#10233; &#8707;ys ys&#39;. xs = ys @ (xs ! n) # ys&#39; &#8743;
  length ys = n &#8743; length ys&#39; = length xs - (n + 1)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> </span><span>xs</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>length_Cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_two</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &lt; n&#39; &#10233; n&#39; &lt; length xs &#10233;
  &#8707;ys ys&#39; ys&#39;&#39;. xs = ys @ (xs ! n) # ys&#39; @ (xs ! n&#39;) # ys&#39;&#39; &#8743; length ys = n &#8743;
  length ys&#39; = n&#39; - (n + 1) &#8743; length ys&#39;&#39; = length xs - (n&#39; + 1)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>n&#39;</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span>split_one</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#39; - 1&quot;</span></span></span><span> </span><span>xs&#39;</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n&#39;_shift</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &lt; n&#39; - 1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#39; - 1 &lt; length xs&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span>ys&#39;</span><span> </span><span>ys&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs&#39; = ys @ xs&#39; ! n # ys&#39; @ xs&#39; ! (n&#39; - 1) # ys&#39;&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;length ys = n&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length ys&#39; = n&#39; - (Suc n + 1)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length ys&#39;&#39; = length xs - (n&#39; + 1)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n&#39;_shift</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x # ys&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>joint_rem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation s (as @ (if &#946; then [case b of Symb b&#39; &#8658; b&#39;] else []), bs) s&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712; nQ&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bs &#8805; (3 + card nQ * card Q) * fnft.max_fanout&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;flip.outs a q (x # xs) q&#39;&#39; b &#946;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length xs &#8805; 1 + card nQ * card Q&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;as = map fst (x # xs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;as&#39; bs&#39; xs&#39;. fnft.computation s (as&#39;, bs&#39;) s&#39; &#8743; flip.outs a q (x # xs&#39;) q&#39;&#39; b &#946; &#8743;
    length bs&#39; &lt; length bs &#8743;
    as&#39; = map fst (x # xs&#39;) @ (if &#946; then [case b of Symb b&#39; &#8658; b&#39;] else [])&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span>cs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>as_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;as = c # cs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>as</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst_x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c = fst x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>as_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s&#39;&#39;</span><span> </span><span>ds</span><span> </span><span>ds&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#948; s c (s&#39;&#39;, ds)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation s&#39;&#39; (cs @ (if &#946; then [case b of Symb b&#39; &#8658; b&#39;] else []), ds&#39;) s&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;bs = ds @ ds&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fnft.computation.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>as_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t&#39;&#39;</span><span> </span><span>es</span><span> </span><span>es&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>lstep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation s&#39;&#39; (cs, es) t&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation t&#39;&#39; (if &#946; then [case b of Symb b&#39; &#8658; b&#39;] else [], es&#39;) s&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ds&#39; = es @ es&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.computation_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s&#39;&#39;_nQ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39;&#39; &#8712; nQ&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>fnft.&#948;_closed</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_es&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length es&#39; &#8804; fnft.max_fanout&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.max_fanout_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fnft.comp_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lstep</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>s&#39;&#39;_nQ</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>lstep</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>fnft.no_step</span><span> </span><span>fnft.step_dest</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_es</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length es &#8805; (1 + card nQ * card Q) * fnft.max_fanout&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(3 + card nQ * card Q) * fnft.max_fanout &#8804; length ds + length es + length es&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>step</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>lstep</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; &#8804; length es + fnft.max_fanout + fnft.max_fanout&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.max_fanout_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>len_es&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>numeral_Bit1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qbs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>qbs_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation_ext s&#39;&#39; (cs, qbs) t&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;es = concat (map snd qbs)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.computation_ext_complete</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lstep</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>qbs_max_fanout</span><span> </span><span class="delimiter">=</span><span> </span><span>fnft.max_fanout_ext_computation</span><span class="delimiter">[</span><span>OF</span><span> </span><span>qbs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>s&#39;&#39;_nQ</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_qbs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs = length xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.computation_ext_length</span><span class="delimiter">[</span><span>OF</span><span> </span><span>qbs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>as_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_qbs&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs = length cs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>len_qbs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>as_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>qss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qss = zip [0..&lt;length qbs] (zip qbs xs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_qss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qss = length qbs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len_qbs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst_qss_at</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;i. i &lt; length qss &#10233; fst (qss ! i) = i&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len_qbs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst_set_qss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. x &#8712; set qss &#10233; fst x &lt; length qss&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len_qbs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>set_zip_leftD</span><span> </span><span>set_zip_rightD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>qss&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qss&#39; = filter (&#955;(n, (q, bs), (bs&#39;, q&#39;)). bs &#8800; []) qss&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst_set_qss&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. x &#8712; set qss&#39; &#10233; x &#8712; set qss&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss&#39;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>qs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs = map (&#955;(n, (q, bs), (bs&#39;, q&#39;)). (q, q&#39;)) qss&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>qss&#39;_at</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;i. i &lt; length qss&#39; &#10233;
    fst (qss&#39; ! i) &lt; length qss &#8743; qss&#39; ! i = qss ! (fst (qss&#39; ! i))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fst_qss_at</span><span> </span><span>fst_set_qss&#39;</span><span> </span><span>fst_set_qss</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_set_qss&#39;</span><span> </span><span>in_set_conv_nth</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>qss&#39;_nonempty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;n q bs bs&#39; q&#39;. (n, (q, bs), (bs&#39;, q&#39;)) &#8712; set qss&#39; &#10233; bs &#8800; []&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss&#39;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sorted_fst_qss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sorted (map fst qss)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct (map fst qss)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len_qbs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sorted_fst_qss&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sorted (map fst qss&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct (map fst qss&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>qss&#39;_def</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sorted_filter</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sorted_fst_qss</span><span> </span><span>distinct_map_filter</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_qs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qs = length qss&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>qs_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set qs &#8838; nQ &#215; Q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.computation_ext_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>qbs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>s&#39;&#39;_nQ</span><span class="delimiter">]</span><span> </span><span>flip.outs_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>          </span><span>len_qbs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span> </span><span>qss&#39;_def</span><span> </span><span>qss_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>set_zip_leftD</span><span> </span><span>set_zip_rightD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>concat_qss&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;concat (map (&#955;(n, (q, bs), (bs&#39;, q&#39;)). bs) qss&#39;) = concat (map snd qbs)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>concat_filter</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[0..&lt;length qbs]&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>len_qbs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss&#39;_def</span><span> </span><span>qss_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_qs_ge</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qs &#8805; 1 + card nQ * card Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>lassm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; length qs &#8805; 1 + card nQ * card Q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (concat (map (&#955;(n, (q, bs), (bs&#39;, q&#39;)). bs) qss&#39;)) &#8804;
      length qss&#39; * fnft.max_fanout&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>concat_length</span><span class="delimiter">[</span><span>of</span><span> </span><span>qss&#39;</span><span> </span><span>fnft.max_fanout</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qbs_max_fanout</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss&#39;_def</span><span> </span><span>qss_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>set_zip_leftD</span><span> </span><span>set_zip_rightD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.max_fanout_pos</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>concat_qss&#39;</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>length</span><span class="delimiter">]</span><span> </span><span>qbs_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>lassm</span><span> </span><span>dual_order.trans</span><span> </span><span>le_less_linear</span><span> </span><span>len_es</span><span> </span><span>len_qs</span><span>
</span><span>          </span><span>mult_le_cancel2</span><span> </span><span>not_less_eq_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_distinct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; distinct qs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;&#172; distinct qs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>contr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct qs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>card_qs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (set qs) &#8805; 1 + card nQ * card Q&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>contr</span><span class="delimiter">]</span><span> </span><span>len_qs_ge</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finite_prod</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (nQ &#215; Q)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.finite_Q</span><span> </span><span>finite_Q</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>card_prod</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (nQ &#215; Q) = card nQ * card Q&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_cartesian_product</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_qs</span><span> </span><span>card_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_prod</span><span> </span><span>qs_sub</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>card_prod</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qc</span><span> </span><span>qs&#39;</span><span> </span><span>qs&#39;&#39;</span><span> </span><span>qs&#39;&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>qs_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs = qs&#39; @ [qc] @ qs&#39;&#39; @ [qc] @ qs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_distinct_decomp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>not_distinct</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n = fst (qss&#39; ! length qs&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>n&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#39; = fst (qss&#39; ! (length qs&#39; + 1 + length qs&#39;&#39;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>valid_idx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qs&#39; &lt; length qss&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qs&#39; + 1 + length qs&#39;&#39; &lt; length qss&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qs_split</span><span> </span><span>len_qs</span><span> </span><span>len_qss</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>qs_split_at</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs ! (length qs&#39;) = qc&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs ! (length qs&#39; + 1 + length qs&#39;&#39;) = qc&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qs_split</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_Suc_right</span><span> </span><span>nth_Cons_Suc</span><span> </span><span>nth_append_length</span><span> </span><span>nth_append_length_plus</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_n&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &lt; n&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#39; &lt; length qbs&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qss ! n = qss&#39; ! length qs&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;qss ! n&#39; = qss&#39; ! (length qs&#39; + 1 + length qs&#39;&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qss&#39;_at</span><span class="delimiter">[</span><span>OF</span><span> </span><span>valid_idx</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>n_def</span><span class="delimiter">]</span><span> </span><span>qss&#39;_at</span><span class="delimiter">[</span><span>OF</span><span> </span><span>valid_idx</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>n&#39;_def</span><span class="delimiter">]</span><span>
</span><span>          </span><span>len_qss</span><span> </span><span>valid_idx</span><span> </span><span>sorted_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sorted_fst_qss&#39;</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>n_def</span><span> </span><span>n&#39;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>qbs_map</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qbs = map (&#955;(n, (q, bs), (bs&#39;, q&#39;)). (q, bs)) qss&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map2_zip</span><span class="delimiter">[</span><span>OF</span><span> </span><span>len_qbs</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[0..&lt;length qbs]&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qbs&#39;</span><span> </span><span>qbs&#39;&#39;</span><span> </span><span>qbs&#39;&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qbs = qbs&#39; @ qbs ! n # qbs&#39;&#39; @ qbs ! n&#39; # qbs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs&#39; = n&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs&#39;&#39; = n&#39; - (n + 1)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs&#39;&#39;&#39; = length qbs - (n&#39; + 1)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_two</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n_n&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bs&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qbs ! n = (fst qc, bs&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qbs_map</span><span> </span><span>n_n&#39;</span><span> </span><span>qs_def</span><span> </span><span>len_qs</span><span> </span><span>qs_split_at</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>valid_idx</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bs&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bs&#39;&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qbs ! n&#39; = (fst qc, bs&#39;&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs&#39;&#39; &#8800; []&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qbs_map</span><span> </span><span>n_n&#39;</span><span> </span><span>qs_def</span><span> </span><span>len_qs</span><span> </span><span>qs_split_at</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>valid_idx</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>qss&#39;_nonempty</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>in_set_conv_nth</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cs&#39;</span><span> </span><span>cs&#39;&#39;</span><span> </span><span>cs&#39;&#39;&#39;</span><span> </span><span>c&#39;</span><span> </span><span>c&#39;&#39;</span><span> </span><span>bs&#39;a</span><span> </span><span>bs&#39;&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>new_comp</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation s&#39;&#39; (cs&#39; @ c&#39; # cs&#39;&#39;&#39;, bs&#39;a @ bs&#39; @ bs&#39;&#39;&#39;) t&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;bs&#39;a = concat (map snd qbs&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs&#39;&#39;&#39; = concat (map snd qbs&#39;&#39;&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;cs = cs&#39; @ c&#39; # cs&#39;&#39; @ c&#39;&#39; # cs&#39;&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length cs&#39; = length qbs&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length cs&#39;&#39; = length qbs&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length cs&#39;&#39;&#39; = length qbs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.computation_ext_rem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>qbs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>decomp</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>bs&#39;_def</span><span> </span><span>bs&#39;&#39;_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>new_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (ds @ bs&#39;a @ bs&#39; @ bs&#39;&#39;&#39; @ es&#39;) &lt; length bs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>step</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>lstep</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>new_comp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>qbs_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>decomp</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bs&#39;_def</span><span> </span><span>bs&#39;&#39;_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xs_map</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs = map (&#955;(n, (q, bs), (bs&#39;, q&#39;)). (bs&#39;, q&#39;)) qss&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map2_zip&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>len_qbs</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[0..&lt;length qbs]&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>xs&#39;&#39;</span><span> </span><span>xs&#39;&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>decomp&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs = xs&#39; @ xs ! n # xs&#39;&#39; @ xs ! n&#39; # xs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length xs&#39; = n&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs&#39;&#39; = n&#39; - (n + 1)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs&#39;&#39;&#39; = length xs - (n&#39; + 1)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_two</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n_n&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>n_n&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>len_qbs</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ys&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs ! n = (ys&#39;, snd qc)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xs_map</span><span> </span><span>n_n&#39;</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>len_qbs</span><span class="delimiter">]</span><span> </span><span>qs_def</span><span> </span><span>len_qs</span><span> </span><span>qs_split_at</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>valid_idx</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ys&#39;&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs ! n&#39; = (ys&#39;&#39;, snd qc)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xs_map</span><span> </span><span>n_n&#39;</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>len_qbs</span><span class="delimiter">]</span><span> </span><span>qs_def</span><span> </span><span>len_qs</span><span> </span><span>qs_split_at</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>valid_idx</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flip.outs a q ((x # xs&#39;) @ (ys&#39;, snd qc) # xs&#39;&#39; @ (ys&#39;&#39;, snd qc) # xs&#39;&#39;&#39;) q&#39;&#39; b &#946;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>decomp&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ys&#39;_def</span><span> </span><span>ys&#39;&#39;_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cs&#39; @ c&#39; # cs&#39;&#39;&#39; = map fst (xs&#39; @ (ys&#39;, snd qc) # xs&#39;&#39;&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>new_comp</span><span class="delimiter">(</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">,</span><span>6</span><span class="delimiter">,</span><span>7</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>decomp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>len_qbs</span><span class="delimiter">]</span><span> </span><span>decomp&#39;</span><span> </span><span>assms</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>as_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ys&#39;_def</span><span> </span><span>ys&#39;&#39;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fnft.step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>new_comp</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>lstep</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>new_length</span><span> </span><span>flip.outs_rem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assoc</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span>step</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fst_x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conflict</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation s (as, bs @ bs&#39;) s&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8605;(as, bs&#39;) r&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712; nQ&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8712; Q&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length bs &#8805; (3 + card nQ * card Q) * fnft.max_fanout * (1 + length bs&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;as&#39; bs&#39;&#39;. fnft.computation s (as&#39;, bs&#39;&#39;) s&#39; &#8743; r &#8605;(as&#39;, bs&#39;) r&#39; &#8743;
    safe_hd as = safe_hd as&#39; &#8743; length bs&#39;&#39; &lt; length (bs @ bs&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>bs&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span>q&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>outs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flip.outs EOF r xs q&#39;&#39; EOF False&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q&#39;&#39; (EOF, EOF) (r&#39;, False, False)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;as = map fst xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>flip_outs_Nil_intro</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Nil</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as &#8805; 3 + card nQ * card Q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Nil</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>fnft.max_fanout_computation</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Nil</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>          </span><span>fnft.max_fanout_pos</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span>cs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs = c # cs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len_as</span><span> </span><span>outs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_cs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;1 + card nQ * card Q &#8804; length cs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>len_as</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>xs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as&#39;</span><span> </span><span>bs&#39;&#39;</span><span> </span><span>xs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>rem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation s (as&#39;, bs&#39;&#39;) s&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;flip.outs EOF r (c # xs&#39;) q&#39;&#39; EOF False&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bs&#39;&#39; &lt; length bs&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;as&#39; = map fst (c # xs&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>joint_rem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>Nil</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>outs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>xs_def</span><span class="delimiter">]</span><span> </span><span>Nil</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>len_cs</span><span class="delimiter">]</span><span>
</span><span>          </span><span>Nil</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span>outs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>xs_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rem&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8605;(map fst (c # xs&#39;), []) r&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>flip_outs_Nil_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rem</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>r&#39;</span><span class="delimiter">]</span><span> </span><span>outs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rem</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>rem&#39;</span><span> </span><span>outs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>xs_def</span><span> </span><span>safe_hd_def</span><span> </span><span>rem</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>as&#39;</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>bs&#39;&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>b</span><span> </span><span>bs&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span>q&#39;&#39;</span><span> </span><span>ba</span><span> </span><span>&#946;</span><span> </span><span>as&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>outs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flip.outs (Symb b) r xs q&#39;&#39; ba &#946;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#39;&#8605;(as&#39;, bs&#39;)r&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(ba = EOF &#10230; &#172; &#946;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#172; &#946; &#10230; ba = flip.safe_hd as&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;as = map fst xs @ (if &#946; then (case ba of Symb b&#39; &#8658; b&#39;) # as&#39; else as&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>flip_outs_Cons_intro</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>q&#39;&#39;_Q</span><span> </span><span class="delimiter">=</span><span> </span><span>flip.outs_closed&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>outs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as &#8805; (3 + card nQ * card Q) * (2 + length bs&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(3 + card nQ * card Q) * (2 + length bs&#39;) * fnft.max_fanout &#8804; length (bs @ b # bs&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>16</span><span class="delimiter">)</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.max_fanout_computation</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>fnft.max_fanout_pos</span><span>
</span><span>            </span><span>le_trans</span><span> </span><span>mult_le_cancel2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>add_gr_0</span><span> </span><span>le_Suc_ex</span><span> </span><span>less_one</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>as_assoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;as = (map fst xs @ (if &#946; then [case ba of Symb b&#39; &#8658; b&#39;] else [])) @ as&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q&#39;</span><span> </span><span>ds</span><span> </span><span>ds&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation s (map fst xs @ (if &#946; then [case ba of Symb b&#39; &#8658; b&#39;] else []), ds) q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation q&#39; (as&#39;, ds&#39;) s&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;bs @ b # bs&#39; = ds @ ds&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.computation_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>as_assoc</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>q&#39;_nQ</span><span> </span><span class="delimiter">=</span><span> </span><span>fnft.comp_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(3 + card nQ * card Q) * fnft.max_fanout &#8804; length ds&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;3 + card nQ * card Q &#8804;
      length (map fst xs @ (if &#946; then [case ba of Symb b&#39; &#8658; b&#39;] else []))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(3 + card nQ * card Q) * fnft.max_fanout &#8804;
        length (map fst xs @ (if &#946; then [case ba of Symb b&#39; &#8658; b&#39;] else [])) * fnft.max_fanout&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>le_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>True</span><span> </span><span>fnft.max_fanout_computation</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.max_fanout_pos</span><span> </span><span>mult_le_cancel2</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>add_gr_0</span><span> </span><span>le_Suc_ex</span><span> </span><span>less_one</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span>cs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs = c # cs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len_as</span><span> </span><span>outs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_cs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;1 + card nQ * card Q &#8804; length cs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len_as</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>xs_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as&#39;&#39;</span><span> </span><span>bs&#39;&#39;</span><span> </span><span>xs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>rem</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation s (as&#39;&#39; @ (if &#946; then [case ba of Symb b&#39; &#8658; b&#39;] else []), bs&#39;&#39;) q&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;flip.outs (Symb b) r (c # xs&#39;) q&#39;&#39; ba &#946;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bs&#39;&#39; &lt; length ds&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;as&#39;&#39; = map fst (c # xs&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>joint_rem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>True</span><span> </span><span>outs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>xs_def</span><span class="delimiter">]</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>len_cs</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>xs_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>rem&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>flip_outs_Cons_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rem</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>outs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>refl</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rem</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>rem&#39;</span><span> </span><span>rem</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>outs</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>rem</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>xs_def</span><span>
</span><span>          </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst c # map fst xs&#39; @ _&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_bs_ds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length ds &#8804; length (bs @ [b])&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>es</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>es_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ds&#39; = es @ bs&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>split_app&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>len_bs_ds</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bs_ds_es</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs @ [b] = ds @ es&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>es_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_es</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(3 + card nQ * card Q) * fnft.max_fanout * (1 + length bs&#39;) &#8804; length es&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(3 + card nQ * card Q) * fnft.max_fanout * (2 + length bs&#39;) &#8804; length (bs @ [b])&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(3 + card nQ * card Q) * fnft.max_fanout * (2 + length bs&#39;) &#8804;
        length ds + length es&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bs_ds_es</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as&#39;&#39;</span><span> </span><span>bs&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>rest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation q&#39; (as&#39;&#39;, bs&#39;&#39;) s&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#39;&#8605;(as&#39;&#39;, bs&#39;)r&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;flip.safe_hd as&#39; = flip.safe_hd as&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bs&#39;&#39; &lt; length (es @ bs&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>es_def</span><span class="delimiter">]</span><span> </span><span>outs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>q&#39;_nQ</span><span> </span><span>q&#39;&#39;_Q</span><span> </span><span>len_es</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>new_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (ds @ bs&#39;&#39;) &lt; length (bs @ b # bs&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rest</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>es_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd as = safe_hd (map fst xs @
      (if &#946; then (case ba of Symb b&#39; &#8658; b&#39;) # as&#39;&#39; else as&#39;&#39;))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rest</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>outs</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>rest</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>new_length</span><span>
</span><span>            </span><span>flip_outs_Cons_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>outs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>rest</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>outs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>outs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>rest</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>refl</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_nQ_pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card nQ &#8805; 1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.finite_Q</span><span> </span><span>fnft.init_in_Q</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_leI</span><span> </span><span>card_gt_0_iff</span><span> </span><span>empty_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_Q_pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card Q &#8805; 1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_Q</span><span> </span><span>init_in_Q</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_leI</span><span> </span><span>card_gt_0_iff</span><span> </span><span>empty_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_nQ_Q_pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card nQ * card Q &#8805; 1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_nQ_pos</span><span> </span><span>card_Q_pos</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_le_mult</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8805; 1 &#10233; y &#8805; 1 &#10233; x + y &#8804; 2 * x * y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_le_mono</span><span> </span><span>distrib_left</span><span> </span><span>mult.commute</span><span> </span><span>mult_2_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Theorem 8 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bounded</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;K. fnft.bounded K&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(&#8707;K. fnft.bounded K)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q</span><span> </span><span>q&#39;</span><span> </span><span>t</span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>unbounded</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation ninit (t, v @ w) q&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.active q []&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation ninit (t, v) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.active q&#39; w&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length w &#8805; (3 + card nQ * card Q) * fnft.max_fanout *
    (3 + (2 + card nQ) * (2 + card Q + fnft.max_fanout)) +
    (card nQ + 2) * (card Q + 2) + 1 + 1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fnft.bounded_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_or_eq_imp_le</span><span> </span><span>neqE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>q_nQ</span><span> </span><span class="delimiter">=</span><span> </span><span>fnft.comp_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>fnft.init_in_Q</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>q&#39;_nQ</span><span> </span><span class="delimiter">=</span><span> </span><span>fnft.comp_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>fnft.init_in_Q</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u1</span><span> </span><span>v1</span><span> </span><span>nqf</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ext</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation q (u1, v1) nqf&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;naccept nqf&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length u1 &#8804; card nQ&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length v1 &#8804; card nQ * fnft.max_fanout&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.active_Nil_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>q_nQ</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u2</span><span> </span><span>v2</span><span> </span><span>nqf&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ext&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation q&#39; (u2, w @ v2) nqf&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;naccept nqf&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length v2 &#8804; (1 + card nQ) * fnft.max_fanout&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.active_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>q&#39;_nQ</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t = u @ [x]&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>fnft.no_step</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length w &#8805; (card nQ + 2) * (card Q + 2) + 1 + 1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v&#39;</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>w_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w = v&#39; @ y # z&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length z = (card nQ + 2) * (card Q + 2) + 1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_long</span><span class="delimiter">[</span><span>OF</span><span> </span><span>len_w</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation ninit (u @ x # u1, (v @ v&#39;) @ y # z @ v1) nqf&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ext</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>w_def</span><span> </span><span>t_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qf</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>qf_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init &#8605;(u @ x # u1, (v @ v&#39;) @ y # z @ v1) qf&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;accept qf&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ext</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>equiv</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fnft.&#964;_def</span><span> </span><span>&#964;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation ninit (u @ x # u2, (v @ v&#39;) @ y # z @ v2) nqf&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>ext&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>w_def</span><span> </span><span>t_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qf&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>qf&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init &#8605;(u @ x # u2, (v @ v&#39;) @ y # z @ v2) qf&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;accept qf&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ext&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>equiv</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fnft.&#964;_def</span><span> </span><span>&#964;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>first_reaches</span><span class="delimiter">[</span><span>OF</span><span> </span><span>reachable_init</span><span> </span><span>refl</span><span> </span><span>refl</span><span> </span><span>qf_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>qf&#39;_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r cs y&#39; cs&#39;. reachable r ([] @ u) ([] @ cs) (Symb x) (Symb y&#39;) &#8743;
      r &#8605;(x # u1, y&#39; # cs&#39; @ z @ v1) qf &#8743; r &#8605;(x # u2, y&#39; # cs&#39; @ z @ v2) qf&#39; &#8743;
      cs @ y&#39; # cs&#39; = (v @ v&#39;) @ [y]&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span>cs</span><span> </span><span>y&#39;</span><span> </span><span>cs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>tail</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;reachable r u cs (Symb x) (Symb y&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8605;(x # u1, y&#39; # cs&#39; @ z @ v1) qf&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length z &#8805; (length u1 + 2) * (card Q + 2) + 1&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>w_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add_le_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ext</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>order.refl</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span>add_le_mono1</span><span> </span><span>mult_le_mono1</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lin_bounded</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tail</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>qf_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r cs x&#39; cs&#39;. reachable r ([] @ cs) ([] @ v @ v&#39;) (Symb x&#39;) (Symb y) &#8743;
      r &#8605;(x&#39; # cs&#39; @ u1, y # z @ v1) qf &#8743; r &#8605;(x&#39; # cs&#39; @ u2, y # z @ v2) qf&#39; &#8743;
      cs @ x&#39; # cs&#39; = u @ [x]&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r&#39;</span><span> </span><span>cs</span><span> </span><span>x&#39;</span><span> </span><span>cs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>tail&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;reachable r&#39; cs (v @ v&#39;) (Symb x&#39;) (Symb y)&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;r&#39; &#8605;(x&#39; # cs&#39; @ u2, y # z @ v2) qf&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cs @ x&#39; # cs&#39; = u @ [x]&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span>gs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u2_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u2 = g # gs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ext&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>w_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>u2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>fnft.no_step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#39; &#8605;((x&#39; # cs&#39;) @ g # gs, y # z @ v2) qf&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tail&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>u2_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span>ds</span><span> </span><span>y&#39;</span><span> </span><span>ds&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>tail</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;reachable r (u @ [x]) (v @ v&#39; @ ds) (Symb g) y&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8605;(g # gs, ds&#39;) qf&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y # z @ v2 = ds @ ds&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#39; = safe_hd ds&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_suf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tail&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>comp</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>tail&#39;</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8712; Q&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tail</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation q&#39; (g # gs, (v&#39; @ ds) @ ds&#39;) nqf&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ext&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>w_def</span><span> </span><span>u2_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span>tail</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_ds&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length ds&#39; &#8804; 2 + (2 + card nQ) * (2 + card Q + fnft.max_fanout)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length ds&#39; &#8804; 1 + length z + length v2&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tail</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>length</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; &#8804; 2 + (2 + card nQ) * (2 + card Q + fnft.max_fanout)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>ext&#39;</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>distrib_left</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_v&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(3 + card nQ * card Q) * fnft.max_fanout * (1 + length ds&#39;) &#8804; length (v&#39; @ ds)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(3 + card nQ * card Q) * fnft.max_fanout * (1 + length ds&#39;) &#8804;
        (3 + card nQ * card Q) * fnft.max_fanout *
        (1 + (2 + (2 + card nQ) * (2 + card Q + fnft.max_fanout)))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult_le_mono2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>add_le_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>len_ds&#39;</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>order.refl</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; &#8804; (3 + card nQ * card Q) * fnft.max_fanout *
        (3 + (2 + card nQ) * (2 + card Q + fnft.max_fanout))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add.assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_or_eq_imp_le</span><span> </span><span>one_plus_numeral</span><span> </span><span>semiring_norm</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; &#8804; length v&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>w_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>w_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as&#39;</span><span> </span><span>bs&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>rem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation q&#39; (as&#39;, bs&#39;&#39;) nqf&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8605;(as&#39;, ds&#39;) qf&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;flip.safe_hd (g # gs) = flip.safe_hd as&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bs&#39;&#39; &lt; length ((v&#39; @ ds) @ ds&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conflict</span><span class="delimiter">[</span><span>OF</span><span> </span><span>comp&#39;</span><span> </span><span>tail</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>q&#39;_nQ</span><span> </span><span>r_Q</span><span> </span><span>len_v&#39;</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wit1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(u @ [x] @ as&#39;, v @ bs&#39;&#39;) &#8712; &#964;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>rem</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>t_def</span><span class="delimiter">]</span><span> </span><span>ext&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>fnft.&#964;_def</span><span> </span><span>equiv</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wit2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(u @ [x] @ as&#39;, v @ v&#39; @ ds @ ds&#39;) &#8712; &#964;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tail</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>rem</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>rem</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>tail</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>qf&#39;_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span> </span><span>&#964;_def</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>functional</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wit1</span><span> </span><span>wit2</span><span class="delimiter">]</span><span> </span><span>rem</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>

</div>
</body>
</html>
