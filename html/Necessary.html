<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Necessary (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Necessary</h1>

<span class="command">theory</span> <span class="name">Necessary</span><br/>
<span class="keyword">imports</span> <a href="Computation.html"><span class="name">Computation</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Necessary</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Computation</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>necessary&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>fnft</span><span class="delimiter">:</span><span> </span><span>fNFT</span><span> </span><span>ninit</span><span> </span><span>n&#948;</span><span> </span><span>naccept</span><span> </span><span>nQ</span><span> </span><span class="delimiter">+</span><span> </span><span>foTDFA</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ninit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a :: finite &#8658; &#39;s &#215; (&#39;b :: finite) list &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>naccept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nQ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;t &#8658; (&#39;a :: finite) Al &#215; (&#39;b :: finite) Al &#8658; &#39;t &#215; bool &#215; bool &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;t &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;t set&quot;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.&#964; = &#964;&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>oTDFA</span><span> </span><span>init</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;q (a, b) (q&#39;, b1, b2). &#948; q (b, a) (q&#39;, b2, b1)&quot;</span></span></span><span> </span><span>accept</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>det</span><span> </span><span>finite_Q</span><span> </span><span>init_in_Q</span><span> </span><span>closed</span><span> </span><span>move_left</span><span> </span><span>move_right</span><span> </span><span>no_step</span><span> </span><span>move_one</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flip_comp_intro</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233; flip.computation q (bs, as) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flip_comp_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flip.computation q (bs, as) q&#39; &#10233; q &#8605;(as, bs) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(bs, as)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>flip.computation.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flip_comp_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flip.computation q (bs, as) q&#39; &#10231; q &#8605;(as, bs) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>flip_comp_intro</span><span> </span><span>flip_comp_dest</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>flip_outs_Nil_intro</span><span> </span><span class="delimiter">=</span><span> </span><span>flip.outs_Nil_intro</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>flip_comp_eq</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>flip_outs_Cons_intro</span><span> </span><span class="delimiter">=</span><span> </span><span>flip.outs_Cons_intro</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>flip_comp_eq</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>flip_outs_Nil_dest</span><span> </span><span class="delimiter">=</span><span> </span><span>flip.outs_Nil_dest</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>flip_comp_eq</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>flip_outs_Cons_dest</span><span> </span><span class="delimiter">=</span><span> </span><span>flip.outs_Cons_dest</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>flip_comp_eq</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_long</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length w &#8805; n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;v&#39; v&#39;&#39;. w = v&#39; @ v&#39;&#39; &#8743; length v&#39;&#39; = n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_take_drop_id</span><span> </span><span>diff_diff_cancel</span><span> </span><span>length_drop</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>concat_filter</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs = length xs &#10233; length ns = length xs &#10233;
  concat (map (&#955;(n, (q, bs), (bs&#39;, q&#39;)). bs) (filter (&#955;(n, (q, bs), (bs&#39;, q&#39;)). bs &#8800; [])
  (zip ns (zip qbs xs)))) = concat (map snd qbs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>qbs</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ns</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_induct2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>xs</span><span> </span><span>y</span><span> </span><span>ys</span><span> </span><span>ns</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ns</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>concat_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;n q bs bs&#39; q&#39;. (n, (q, bs), (bs&#39;, q&#39;)) &#8712; set qss&#39; &#10233; length bs &#8804; d) &#10233;
  length (concat (map (&#955;(n, (q, bs), (bs&#39;, q&#39;)). bs) qss&#39;)) &#8804; length qss&#39; * d&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>qss&#39;</span><span class="delimiter">)</span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sorted xs &#10233; distinct xs &#10233; i &lt; j &#10233; j &lt; length xs &#10233; xs ! i &lt; xs ! j&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_le</span><span> </span><span>nth_eq_iff_index_eq</span><span> </span><span>sorted_iff_nth_mono_less</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map2_zip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs = length xs &#10233; length qbs = length ns &#10233;
  qbs = map2 (&#955;n ((q, bs), (bs&#39;, q&#39;)). (q, bs)) ns (zip qbs xs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>qbs</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ns</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_induct2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>xs</span><span> </span><span>y</span><span> </span><span>ys</span><span> </span><span>ns</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ns</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map2_zip&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs = length xs &#10233; length qbs = length ns &#10233;
  xs = map2 (&#955;n ((q, bs), (bs&#39;, q&#39;)). (bs&#39;, q&#39;)) ns (zip qbs xs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>qbs</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ns</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_induct2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>xs</span><span> </span><span>y</span><span> </span><span>ys</span><span> </span><span>ns</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ns</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_one</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &lt; length xs &#10233; &#8707;ys ys&#39;. xs = ys @ (xs ! n) # ys&#39; &#8743;
  length ys = n &#8743; length ys&#39; = length xs - (n + 1)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> </span><span>xs</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>length_Cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_two</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &lt; n&#39; &#10233; n&#39; &lt; length xs &#10233;
  &#8707;ys ys&#39; ys&#39;&#39;. xs = ys @ (xs ! n) # ys&#39; @ (xs ! n&#39;) # ys&#39;&#39; &#8743; length ys = n &#8743;
  length ys&#39; = n&#39; - (n + 1) &#8743; length ys&#39;&#39; = length xs - (n&#39; + 1)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>n&#39;</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span>split_one</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#39; - 1&quot;</span></span></span><span> </span><span>xs&#39;</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n&#39;_shift</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &lt; n&#39; - 1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#39; - 1 &lt; length xs&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span>ys&#39;</span><span> </span><span>ys&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs&#39; = ys @ xs&#39; ! n # ys&#39; @ xs&#39; ! (n&#39; - 1) # ys&#39;&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;length ys = n&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length ys&#39; = n&#39; - (Suc n + 1)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length ys&#39;&#39; = length xs - (n&#39; + 1)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n&#39;_shift</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x # ys&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>joint_rem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation s (as, bs) s&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712; nQ&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bs &gt; card nQ * card Q * fnft.output_speed&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;flip.outs a q xs q&#39;&#39; b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length xs &gt; card nQ * card Q&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;as = map fst xs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;as&#39; bs&#39; xs&#39;. fnft.computation s (as&#39;, bs&#39;) s&#39; &#8743; flip.outs a q xs&#39; q&#39;&#39; b &#8743;
    length bs&#39; &lt; length bs &#8743; as&#39; = map fst xs&#39; &#8743; safe_hd (map fst xs&#39;) = safe_hd (map fst xs)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qbs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>qbs_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation_ext s (as, qbs) s&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs = concat (map snd qbs)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.computation_ext_complete</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>qbs_output_speed</span><span> </span><span class="delimiter">=</span><span> </span><span>fnft.output_speed_ext_computation</span><span class="delimiter">[</span><span>OF</span><span> </span><span>qbs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_qbs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs = length xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.computation_ext_length</span><span class="delimiter">[</span><span>OF</span><span> </span><span>qbs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_qbs&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs = length as&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>len_qbs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>qss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qss = zip [0..&lt;length qbs] (zip qbs xs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_qss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qss = length qbs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len_qbs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst_qss_at</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;i. i &lt; length qss &#10233; fst (qss ! i) = i&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len_qbs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst_set_qss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. x &#8712; set qss &#10233; fst x &lt; length qss&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len_qbs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>set_zip_leftD</span><span> </span><span>set_zip_rightD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>qss&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qss&#39; = filter (&#955;(n, (q, bs), (bs&#39;, q&#39;)). bs &#8800; []) qss&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst_set_qss&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. x &#8712; set qss&#39; &#10233; x &#8712; set qss&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss&#39;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>qs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs = map (&#955;(n, (q, bs), (bs&#39;, q&#39;)). (q, q&#39;)) qss&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>qss&#39;_at</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;i. i &lt; length qss&#39; &#10233;
    fst (qss&#39; ! i) &lt; length qss &#8743; qss&#39; ! i = qss ! (fst (qss&#39; ! i))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fst_qss_at</span><span> </span><span>fst_set_qss&#39;</span><span> </span><span>fst_set_qss</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_set_qss&#39;</span><span> </span><span>in_set_conv_nth</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>qss&#39;_nonempty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;n q bs bs&#39; q&#39;. (n, (q, bs), (bs&#39;, q&#39;)) &#8712; set qss&#39; &#10233; bs &#8800; []&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss&#39;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sorted_fst_qss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sorted (map fst qss)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct (map fst qss)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len_qbs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sorted_fst_qss&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sorted (map fst qss&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct (map fst qss&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>qss&#39;_def</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sorted_filter</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sorted_fst_qss</span><span> </span><span>distinct_map_filter</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_qs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qs = length qss&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>qs_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set qs &#8838; nQ &#215; Q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.computation_ext_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>qbs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>flip.outs_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>          </span><span>len_qbs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span> </span><span>qss&#39;_def</span><span> </span><span>qss_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>set_zip_leftD</span><span> </span><span>set_zip_rightD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>concat_qss&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;concat (map (&#955;(n, (q, bs), (bs&#39;, q&#39;)). bs) qss&#39;) = concat (map snd qbs)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>concat_filter</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[0..&lt;length qbs]&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>len_qbs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss&#39;_def</span><span> </span><span>qss_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_qs_ge</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qs &#8805; 1 + card nQ * card Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>lassm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; length qs &#8805; 1 + card nQ * card Q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (concat (map (&#955;(n, (q, bs), (bs&#39;, q&#39;)). bs) qss&#39;)) &#8804;
      length qss&#39; * fnft.output_speed&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>concat_length</span><span class="delimiter">[</span><span>of</span><span> </span><span>qss&#39;</span><span> </span><span>fnft.output_speed</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qbs_output_speed</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss&#39;_def</span><span> </span><span>qss_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>set_zip_leftD</span><span> </span><span>set_zip_rightD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.output_speed_pos</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>lassm</span><span> </span><span>less_le_trans</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>concat_qss&#39;</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>length</span><span class="delimiter">]</span><span> </span><span>qbs_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>len_qs</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_distinct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; distinct qs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;&#172; distinct qs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>contr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct qs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>card_qs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (set qs) &#8805; 1 + card nQ * card Q&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>contr</span><span class="delimiter">]</span><span> </span><span>len_qs_ge</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finite_prod</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (nQ &#215; Q)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.finite_Q</span><span> </span><span>finite_Q</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>card_prod</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (nQ &#215; Q) = card nQ * card Q&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_cartesian_product</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_qs</span><span> </span><span>card_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_prod</span><span> </span><span>qs_sub</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>card_prod</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qc</span><span> </span><span>qs&#39;</span><span> </span><span>qs&#39;&#39;</span><span> </span><span>qs&#39;&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>qs_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs = qs&#39; @ [qc] @ qs&#39;&#39; @ [qc] @ qs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_distinct_decomp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>not_distinct</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n = fst (qss&#39; ! length qs&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>n&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#39; = fst (qss&#39; ! (length qs&#39; + 1 + length qs&#39;&#39;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>valid_idx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qs&#39; &lt; length qss&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qs&#39; + 1 + length qs&#39;&#39; &lt; length qss&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qs_split</span><span> </span><span>len_qs</span><span> </span><span>len_qss</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>qs_split_at</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs ! (length qs&#39;) = qc&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs ! (length qs&#39; + 1 + length qs&#39;&#39;) = qc&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qs_split</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_Suc_right</span><span> </span><span>nth_Cons_Suc</span><span> </span><span>nth_append_length</span><span> </span><span>nth_append_length_plus</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_n&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &lt; n&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#39; &lt; length qbs&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qss ! n = qss&#39; ! length qs&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;qss ! n&#39; = qss&#39; ! (length qs&#39; + 1 + length qs&#39;&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qss&#39;_at</span><span class="delimiter">[</span><span>OF</span><span> </span><span>valid_idx</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>n_def</span><span class="delimiter">]</span><span> </span><span>qss&#39;_at</span><span class="delimiter">[</span><span>OF</span><span> </span><span>valid_idx</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>n&#39;_def</span><span class="delimiter">]</span><span>
</span><span>          </span><span>len_qss</span><span> </span><span>valid_idx</span><span> </span><span>sorted_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sorted_fst_qss&#39;</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>n_def</span><span> </span><span>n&#39;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>qbs_map</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qbs = map (&#955;(n, (q, bs), (bs&#39;, q&#39;)). (q, bs)) qss&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map2_zip</span><span class="delimiter">[</span><span>OF</span><span> </span><span>len_qbs</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[0..&lt;length qbs]&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qbs&#39;</span><span> </span><span>qbs&#39;&#39;</span><span> </span><span>qbs&#39;&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qbs = qbs&#39; @ qbs ! n # qbs&#39;&#39; @ qbs ! n&#39; # qbs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs&#39; = n&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs&#39;&#39; = n&#39; - (n + 1)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs&#39;&#39;&#39; = length qbs - (n&#39; + 1)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_two</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n_n&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bs&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qbs ! n = (fst qc, bs&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qbs_map</span><span> </span><span>n_n&#39;</span><span> </span><span>qs_def</span><span> </span><span>len_qs</span><span> </span><span>qs_split_at</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>valid_idx</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bs&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bs&#39;&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qbs ! n&#39; = (fst qc, bs&#39;&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs&#39;&#39; &#8800; []&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qbs_map</span><span> </span><span>n_n&#39;</span><span> </span><span>qs_def</span><span> </span><span>len_qs</span><span> </span><span>qs_split_at</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>valid_idx</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>qss&#39;_nonempty</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>in_set_conv_nth</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cs&#39;</span><span> </span><span>cs&#39;&#39;</span><span> </span><span>cs&#39;&#39;&#39;</span><span> </span><span>c&#39;</span><span> </span><span>c&#39;&#39;</span><span> </span><span>bs&#39;a</span><span> </span><span>bs&#39;&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>new_comp</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation s (cs&#39; @ c&#39; # cs&#39;&#39;&#39;, bs&#39;a @ bs&#39; @ bs&#39;&#39;&#39;) s&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;bs&#39;a = concat (map snd qbs&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs&#39;&#39;&#39; = concat (map snd qbs&#39;&#39;&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;as = cs&#39; @ c&#39; # cs&#39;&#39; @ c&#39;&#39; # cs&#39;&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length cs&#39; = length qbs&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length cs&#39;&#39; = length qbs&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length cs&#39;&#39;&#39; = length qbs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.computation_ext_rem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>qbs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>decomp</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>bs&#39;_def</span><span> </span><span>bs&#39;&#39;_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>new_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (bs&#39;a @ bs&#39; @ bs&#39;&#39;&#39;) &lt; length bs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>new_comp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>qbs_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>decomp</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bs&#39;_def</span><span> </span><span>bs&#39;&#39;_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xs_map</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs = map (&#955;(n, (q, bs), (bs&#39;, q&#39;)). (bs&#39;, q&#39;)) qss&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map2_zip&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>len_qbs</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[0..&lt;length qbs]&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qss_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>xs&#39;&#39;</span><span> </span><span>xs&#39;&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>decomp&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs = xs&#39; @ xs ! n # xs&#39;&#39; @ xs ! n&#39; # xs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length xs&#39; = n&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs&#39;&#39; = n&#39; - (n + 1)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs&#39;&#39;&#39; = length xs - (n&#39; + 1)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_two</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n_n&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>n_n&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>len_qbs</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ys&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs ! n = (ys&#39;, snd qc)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xs_map</span><span> </span><span>n_n&#39;</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>len_qbs</span><span class="delimiter">]</span><span> </span><span>qs_def</span><span> </span><span>len_qs</span><span> </span><span>qs_split_at</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>valid_idx</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ys&#39;&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs ! n&#39; = (ys&#39;&#39;, snd qc)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xs_map</span><span> </span><span>n_n&#39;</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>len_qbs</span><span class="delimiter">]</span><span> </span><span>qs_def</span><span> </span><span>len_qs</span><span> </span><span>qs_split_at</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>valid_idx</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flip.outs a q (xs&#39; @ (ys&#39;, snd qc) # xs&#39;&#39; @ (ys&#39;&#39;, snd qc) # xs&#39;&#39;&#39;) q&#39;&#39; b&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>decomp&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ys&#39;_def</span><span> </span><span>ys&#39;&#39;_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cs&#39; @ c&#39; # cs&#39;&#39;&#39; = map fst (xs&#39; @ (ys&#39;, snd qc) # xs&#39;&#39;&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>new_comp</span><span class="delimiter">(</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">,</span><span>6</span><span class="delimiter">,</span><span>7</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>decomp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>len_qbs</span><span class="delimiter">]</span><span> </span><span>decomp&#39;</span><span> </span><span>assms</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ys&#39;_def</span><span> </span><span>ys&#39;&#39;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (map fst (xs&#39; @ (ys&#39;, snd qc) # xs&#39;&#39;&#39;)) = safe_hd (map fst xs)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>safe_hd_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>decomp&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ys&#39;_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>new_comp</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>new_length</span><span> </span><span>flip.outs_rem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assoc</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_nQ_pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card nQ &#8805; 1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.finite_Q</span><span> </span><span>fnft.init_in_Q</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_leI</span><span> </span><span>card_gt_0_iff</span><span> </span><span>empty_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_Q_pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card Q &#8805; 1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_Q</span><span> </span><span>init_in_Q</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_leI</span><span> </span><span>card_gt_0_iff</span><span> </span><span>empty_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_nQ_Q_pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card nQ * card Q &#8805; 1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_nQ_pos</span><span> </span><span>card_Q_pos</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_all</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8804; card nQ * card Q * fnft.output_speed * x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_nQ_Q_pos</span><span> </span><span>fnft.output_speed_pos</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conflict</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation s (as, bs @ bs&#39;) s&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8605;(as, bs&#39;) r&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712; nQ&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8712; Q&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length bs + length bs&#39; &gt; card nQ * card Q * fnft.output_speed * (1 + length bs&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;as&#39; bs&#39;&#39;. fnft.computation s (as&#39;, bs&#39;&#39;) s&#39; &#8743; r &#8605;(as&#39;, bs&#39;) r&#39; &#8743;
    safe_hd as = safe_hd as&#39; &#8743; length bs&#39;&#39; &lt; length (bs @ bs&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>bs&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span>q&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>outs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flip.outs Blank r xs q&#39;&#39; Blank&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q&#39;&#39; (Blank, Blank) (r&#39;, False, False)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;as = map fst xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>flip_outs_Nil_intro</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Nil</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as &gt; card nQ * card Q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_le_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Nil</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>          </span><span>fnft.output_speed_computation</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Nil</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>          </span><span>fnft.output_speed_pos</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as&#39;</span><span> </span><span>bs&#39;&#39;</span><span> </span><span>xs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>rem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation s (as&#39;, bs&#39;&#39;) s&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;flip.outs Blank r xs&#39; q&#39;&#39; Blank&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bs&#39;&#39; &lt; length bs&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;as&#39; = map fst xs&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (map fst xs&#39;) = safe_hd (map fst xs)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>joint_rem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Nil</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>outs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Nil</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>outs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>Nil</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>len_as</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>outs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rem&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8605;(map fst xs&#39;, []) r&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>flip_outs_Nil_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rem</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>r&#39;</span><span class="delimiter">]</span><span> </span><span>outs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rem</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span>rem&#39;</span><span> </span><span>outs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>rem</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>as&#39;</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>bs&#39;&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>b</span><span> </span><span>bs&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span>q&#39;&#39;</span><span> </span><span>ba</span><span> </span><span>as&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>outs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flip.outs (Symb b) r xs q&#39;&#39; ba&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#39;&#8605;(as&#39;, bs&#39;)r&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;ba = safe_hd as&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;as = map fst xs @ as&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>flip_outs_Cons_intro</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>q&#39;&#39;_Q</span><span> </span><span class="delimiter">=</span><span> </span><span>flip.outs_closed&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>outs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as &#8805; card nQ * card Q * (2 + length bs&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card nQ * card Q * (2 + length bs&#39;) * fnft.output_speed &#8804; length (bs @ b # bs&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>16</span><span class="delimiter">)</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.output_speed_computation</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>fnft.output_speed_pos</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_le_eq</span><span> </span><span>le_trans</span><span> </span><span>mult_le_cancel2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q&#39;</span><span> </span><span>ds</span><span> </span><span>ds&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation s (map fst xs, ds) q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation q&#39; (as&#39;, ds&#39;) s&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;bs @ b # bs&#39; = ds @ ds&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.computation_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>outs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>q&#39;_nQ</span><span> </span><span class="delimiter">=</span><span> </span><span>fnft.comp_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card nQ * card Q * fnft.output_speed &lt; length ds&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card nQ * card Q &lt; length (map fst xs)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card nQ * card Q * fnft.output_speed &lt; length (map fst xs) * fnft.output_speed&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>less_le_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>True</span><span> </span><span>fnft.output_speed_computation</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.output_speed_pos</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as&#39;&#39;</span><span> </span><span>bs&#39;&#39;</span><span> </span><span>xs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>rem</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation s (as&#39;&#39;, bs&#39;&#39;) q&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;flip.outs (Symb b) r xs&#39; q&#39;&#39; ba&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bs&#39;&#39; &lt; length ds&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;as&#39;&#39; = map fst xs&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (map fst xs&#39;) = safe_hd (map fst xs)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>joint_rem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>True</span><span> </span><span>outs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>len_as</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>rem&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>flip_outs_Cons_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rem</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>outs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>refl</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rem</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>rem&#39;</span><span> </span><span>rem</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>outs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>safe_hd_app</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rem</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>rem</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map fst xs&#39; @ as&#39;&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_bs_ds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length ds &#8804; length (bs @ [b])&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>mult_all</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (b # bs&#39;)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>es</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>es_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ds&#39; = es @ bs&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>split_app&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>len_bs_ds</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bs_ds_es</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs @ [b] = ds @ es&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>es_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_es</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card nQ * card Q * fnft.output_speed * (1 + length bs&#39;) &lt; length es + length bs&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card nQ * card Q * fnft.output_speed * (1 + length bs&#39;) + length ds &#8804;
        card nQ * card Q * fnft.output_speed * (1 + length bs&#39;) +
        card nQ * card Q * fnft.output_speed&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; &lt; length ds + length es + length bs&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bs_ds_es</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>length</span><span class="delimiter">]</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as&#39;&#39;</span><span> </span><span>bs&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>rest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation q&#39; (as&#39;&#39;, bs&#39;&#39;) s&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#39;&#8605;(as&#39;&#39;, bs&#39;)r&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd as&#39; = safe_hd as&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bs&#39;&#39; &lt; length (es @ bs&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>es_def</span><span class="delimiter">]</span><span> </span><span>outs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>q&#39;_nQ</span><span> </span><span>q&#39;&#39;_Q</span><span class="delimiter">]</span><span> </span><span>len_es</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>new_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (ds @ bs&#39;&#39;) &lt; length (bs @ b # bs&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rest</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>es_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd as = safe_hd (map fst xs @ as&#39;&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>safe_hd_app&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rest</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>outs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>outs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>rest</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>new_length</span><span>
</span><span>        </span><span>flip_outs_Cons_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>outs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>rest</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>outs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>rest</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>refl</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bounded</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;K. fnft.bounded K&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* home stretch *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>h</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h = (fnft.sg + 1) * (card Q + 1)&quot;</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* trail length *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t = card nQ * card Q * fnft.output_speed *
    (h + (fnft.sg + 1) * fnft.output_speed + 1)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(&#8707;K. fnft.bounded K)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q</span><span> </span><span>q&#39;</span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>unbounded</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation ninit (u, v @ w) q&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.active q []&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation ninit (u, v) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.active q&#39; w&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length w &gt; t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fnft.bounded_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_or_eq_imp_le</span><span> </span><span>neqE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>q_nQ</span><span> </span><span class="delimiter">=</span><span> </span><span>fnft.comp_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>fnft.init_in_Q</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>q&#39;_nQ</span><span> </span><span class="delimiter">=</span><span> </span><span>fnft.comp_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>fnft.init_in_Q</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u1</span><span> </span><span>v1</span><span> </span><span>nqf</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ext</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation q (u1, v1) nqf&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;naccept nqf&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length u1 &#8804; fnft.sg&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length v1 &#8804; fnft.sg * fnft.output_speed&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.active_Nil_dest_sg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>q_nQ</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u2</span><span> </span><span>v2</span><span> </span><span>nqf&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ext&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation q&#39; (u2, w @ v2) nqf&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;naccept nqf&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length v2 &#8804; (1 + fnft.sg) * fnft.output_speed&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.active_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>q&#39;_nQ</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>len_w_gt</span><span> </span><span class="delimiter">=</span><span> </span><span>le_less_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mult_all</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h + (fnft.sg + 1) * fnft.output_speed + 1&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>unbounded</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>t_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length w &#8805; h&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len_w_gt</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v&#39;</span><span> </span><span>v&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>w_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w = v&#39; @ v&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length v&#39;&#39; = h&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_long</span><span class="delimiter">[</span><span>OF</span><span> </span><span>len_w</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation ninit (u @ u1, (v @ v&#39;) @ v&#39;&#39; @ v1) nqf&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ext</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>w_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qf</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>qf_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init &#8605;(u @ u1, (v @ v&#39;) @ v&#39;&#39; @ v1) qf&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;accept qf&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ext</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>equiv</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fnft.&#964;_def</span><span> </span><span>&#964;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation ninit (u @ u2, (v @ v&#39;) @ v&#39;&#39; @ v2) nqf&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>ext&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>w_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qf&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>qf&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init &#8605;(u @ u2, (v @ v&#39;) @ v&#39;&#39; @ v2) qf&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;accept qf&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ext&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>equiv</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fnft.&#964;_def</span><span> </span><span>&#964;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>u_not_Nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u &#8800; []&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.output_speed_computation</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>fnft.init_in_Q</span><span class="delimiter">]</span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>t_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v&#39;&#39;_not_Nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v&#39;&#39; &#8800; []&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>h_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>safe_hd_v&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (v&#39;&#39; @ v1) = safe_hd (v&#39;&#39; @ v2)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>safe_hd_app&#39;&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>v&#39;&#39;_not_Nil</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>reach_init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;reachable init [] [] (safe_hd (u @ u1)) (safe_hd ((v @ v&#39;) @ v&#39;&#39; @ v1))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reachable_init</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>safe_hd_u1_u2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (u @ u1) = safe_hd (u @ u2)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>safe_hd_app&#39;&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u_not_Nil</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>first_reaches</span><span class="delimiter">[</span><span>OF</span><span> </span><span>reach_init</span><span> </span><span>safe_hd_u1_u2</span><span> </span><span>safe_hd_v&#39;&#39;</span><span> </span><span>qf_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>qf&#39;_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r cs c cs&#39;. reachable r ([] @ u) ([] @ cs) (safe_hd u1) c &#8743;
      r&#8605;(u1, cs&#39; @ v&#39;&#39; @ v1)qf &#8743; r&#8605;(u2, cs&#39; @ v&#39;&#39; @ v2)qf&#39; &#8743; cs @ cs&#39; = v @ v&#39; &#8743;
      c = safe_hd (cs&#39; @ v&#39;&#39; @ v1) &#8743; c = safe_hd (cs&#39; @ v&#39;&#39; @ v2)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span>cs</span><span> </span><span>c</span><span> </span><span>cs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>tail</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;reachable r u cs (safe_hd u1) c&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8605;(u1, cs&#39; @ v&#39;&#39; @ v1) qf&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c = safe_hd (cs&#39; @ v&#39;&#39; @ v1)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(length u1 + 1) * card Q &#8804; (fnft.sg + 1) * card Q&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ext</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lin_bounded</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tail</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>qf_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>refl</span><span> </span><span>tail</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>le</span><span class="delimiter">]</span><span> </span><span>w_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>h_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r cs c cs&#39;. reachable r ([] @ cs) ([] @ v @ v&#39;) c (safe_hd (v&#39;&#39; @ v1)) &#8743;
      r&#8605;(cs&#39; @ u1, v&#39;&#39; @ v1)qf &#8743; r&#8605;(cs&#39; @ u2, v&#39;&#39; @ v2)qf&#39; &#8743; cs @ cs&#39; = u &#8743;
      c = safe_hd (cs&#39; @ u1) &#8743; c = safe_hd (cs&#39; @ u2)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r&#39;</span><span> </span><span>cs</span><span> </span><span>c</span><span> </span><span>cs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>tail&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;reachable r&#39; cs (v @ v&#39;) c (safe_hd (v&#39;&#39; @ v1))&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;r&#39; &#8605;(cs&#39; @ u2, v&#39;&#39; @ v2) qf&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cs @ cs&#39; = u&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c = safe_hd (cs&#39; @ u2)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span>fs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u2_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u2 = f # fs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.output_speed_computation</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ext&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>q&#39;_nQ</span><span class="delimiter">]</span><span> </span><span>len_w_gt</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>u2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#39; &#8605;(cs&#39; @ f # fs, v&#39;&#39; @ v2) qf&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tail&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>u2_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c = safe_hd (cs&#39; @ [f])&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tail&#39;</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u2_def</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_eq_append_conv</span><span> </span><span>list.inject</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span>ds</span><span> </span><span>y&#39;</span><span> </span><span>ds&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>tail</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;reachable r u (v @ v&#39; @ ds) (Symb f) y&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8605;(f # fs, ds&#39;) qf&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v&#39;&#39; @ v2 = ds @ ds&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y&#39; = safe_hd ds&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_suf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tail&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>safe_hd_v&#39;&#39;</span><span> </span><span>comp</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>tail&#39;</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>u2_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>tail&#39;</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8712; Q&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tail</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation q&#39; (f # fs, (v&#39; @ ds) @ ds&#39;) nqf&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ext&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>w_def</span><span> </span><span>u2_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span>tail</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_ds&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length ds&#39; &#8804; h + (fnft.sg + 1) * fnft.output_speed&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tail</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>length</span><span class="delimiter">]</span><span> </span><span>w_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>ext&#39;</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_v&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card nQ * card Q * fnft.output_speed * (1 + length ds&#39;) &lt; length (v&#39; @ ds @ ds&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card nQ * card Q * fnft.output_speed * (1 + length ds&#39;) &#8804; t&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len_ds&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>t_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; &lt; length (v&#39; @ v&#39;&#39;)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>w_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tail</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as&#39;</span><span> </span><span>bs&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>rem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.computation q&#39; (as&#39;, bs&#39;&#39;) nqf&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8605;(as&#39;, ds&#39;) qf&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (f # fs) = safe_hd as&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bs&#39;&#39; &lt; length ((v&#39; @ ds) @ ds&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conflict</span><span class="delimiter">[</span><span>OF</span><span> </span><span>comp&#39;</span><span> </span><span>tail</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>q&#39;_nQ</span><span> </span><span>r_Q</span><span class="delimiter">]</span><span> </span><span>len_v&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wit1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(u @ as&#39;, v @ bs&#39;&#39;) &#8712; &#964;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fnft.comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unbounded</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>rem</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>ext&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>fnft.&#964;_def</span><span> </span><span>equiv</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wit2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(u @ as&#39;, v @ v&#39; @ ds @ ds&#39;) &#8712; &#964;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tail</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>rem</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>rem</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>tail</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>qf&#39;_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span> </span><span>&#964;_def</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>functional</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wit1</span><span> </span><span>wit2</span><span class="delimiter">]</span><span> </span><span>rem</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>necessary</span><span> </span><span class="delimiter">=</span><span> </span><span>fnft</span><span class="delimiter">:</span><span> </span><span>fNFT</span><span> </span><span>ninit</span><span> </span><span>n&#948;</span><span> </span><span>naccept</span><span> </span><span>nQ</span><span> </span><span class="delimiter">+</span><span> </span><span>fTDFA</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ninit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a :: finite &#8658; &#39;s &#215; (&#39;b :: finite) list &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>naccept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nQ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;t &#8658; (&#39;a :: finite) Al &#215; (&#39;b :: finite) Al &#8658; &#39;t &#215; bool &#215; bool &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;t &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;t set&quot;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fnft.&#964; = &#964;&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>otdfa</span><span class="delimiter">:</span><span> </span><span>oTDFA</span><span> </span><span>otdfa_init</span><span> </span><span>otdfa_delta</span><span> </span><span>otdfa_accept</span><span> </span><span>otdfa_Q</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>otdfa_det</span><span> </span><span>otdfa_finite_Q</span><span> </span><span>otdfa_init_in_Q</span><span> </span><span>otdfa_closed</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span>
</span><span>        </span><span>otdfa_move_left</span><span> </span><span>otdfa_move_right</span><span> </span><span>otdfa_no_step</span><span> </span><span>otdfa_move_one</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>nec</span><span class="delimiter">:</span><span> </span><span>necessary&#39;</span><span> </span><span>ninit</span><span> </span><span>n&#948;</span><span> </span><span>naccept</span><span> </span><span>nQ</span><span> </span><span>otdfa_init</span><span> </span><span>otdfa_delta</span><span> </span><span>otdfa_accept</span><span> </span><span>otdfa_Q</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>functional</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>equiv</span><span> </span><span>tdfa_equiv_otdfa</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Theorem 10 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bounded</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;K. fnft.bounded K&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nec.bounded</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>

</div>
</body>
</html>
