<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Computation (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Computation</h1>

<span class="command">theory</span> <span class="name">Computation</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Computation</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* general helper lemmas *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;xs ys xs&#39; ys&#39;. xs @ ys = xs&#39; @ ys&#39; &#10233; length xs &#8804; length xs&#39; &#10233;
  &#8707;ds. xs&#39; = xs @ ds&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>append_eq_append_conv_if</span><span> </span><span>append_eq_conv_conj</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_app&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;xs ys xs&#39; ys&#39;. xs @ ys = xs&#39; @ ys&#39; &#10233; length xs &#8804; length xs&#39; &#10233;
  &#8707;es. ys = es @ ys&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>append_eq_append_conv_if</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_decomp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs = length (ys @ ys&#39;) &#10233;
  &#8707;zs zs&#39;. xs = zs @ zs&#39; &#8743; length zs = length ys &#8743; length zs&#39; = length ys&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_eq_conv_conj</span><span> </span><span>length_drop</span><span> </span><span>length_rev</span><span> </span><span>rev_take</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>singleton_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs = Suc 0 &#10233; &#8707;x. xs = [x]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_zip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set (zip xs ys) &#8838; set xs &#215; set ys&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ys</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>set_zip_leftD</span><span> </span><span>set_zip_rightD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_ext</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map f xs = ys @ ys&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;zs zs&#39;. xs = zs @ zs&#39; &#8743; map f zs = ys &#8743; map f zs&#39; = ys&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>zs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = take (length ys) xs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>zs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs&#39; = drop (length ys) xs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs = zs @ zs&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map f zs = ys&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map f zs&#39; = ys&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>append_eq_conv_conj</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zs_def</span><span> </span><span>zs&#39;_def</span><span> </span><span>take_map</span><span> </span><span>drop_map</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>iter_concat</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; &#39;a list &#8658; &#39;a list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;iter_concat 0 xs = []&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;iter_concat (Suc n) xs = xs @ iter_concat n xs&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter_concat_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (iter_concat n xs) = n * length xs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>iter_concat.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_finite_product_subset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;finite Q &#10233; QS&#39; &#8838; Q &#215; Q &#10233; card QS&#39; &#8804; card Q * card Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>card_cartesian_product</span><span> </span><span>card_mono</span><span> </span><span>finite_cartesian_product</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_bounded_lists</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite {bs :: (&#39;b :: finite) list. length bs &#8804; n}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{bs :: &#39;b list. length bs &#8804; Suc n} = {bs. length bs &#8804; n} &#8746; {bs. length bs = Suc n}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{bs :: &#39;b list. length bs = Suc n} &#8838; (&#8899;(b, bs) &#8712; UNIV &#215; {bs. length bs &#8804; n}. {b # bs})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; {bs :: &#39;b list. length bs = Suc n}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; (&#8899;(b, bs)&#8712;UNIV &#215; {bs. length bs &#8804; n}. {b # bs})&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (&#8899;(b, bs) &#8712; UNIV &#215; {bs :: &#39;b list. length bs &#8804; n}. {b # bs})&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite {bs :: &#39;b list. length bs = Suc n}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>infinite_super</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc</span><span> </span><span>split</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* alphabet extended with a special blank symbol *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">&#39;a</span><span> </span><span>Al</span><span> </span><span class="delimiter">=</span><span> </span><span>Symb</span><span> </span><span class="delimiter">(</span><span>the_Symb</span><span class="delimiter">:</span><span> </span><span class="tfree">&#39;a</span><span class="delimiter">)</span><span> </span><span class="delimiter">|</span><span> </span><span>Blank</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd bs&#39; = (case bs&#39; of [] &#8658; Blank | b # bs &#8658; Symb b)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_hd_Nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd [] = Blank&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_hd_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs = xs&#39; @ (bs, q&#39;&#39;) # xs&#39;&#39; &#10233;
  safe_hd (map fst xs) = safe_hd (map fst (xs&#39; @ (bs, q&#39;&#39;) # xs&#39;&#39;&#39;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_eq_append_conv</span><span> </span><span>nth_Cons_0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_hd_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd xs = safe_hd xs&#39; &#10233; safe_hd (xs @ ys) = safe_hd (xs&#39; @ ys)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_hd_app&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd ys = safe_hd ys&#39; &#10233; safe_hd (xs @ ys) = safe_hd (xs @ ys&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Nil</span><span> </span><span>hd_append2</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_hd_app&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs &#8800; [] &#10233; safe_hd (xs @ ys) = safe_hd (xs @ ys&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_hd_Cons_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (xs @ x # ys) = safe_hd (xs @ x # ys&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Definition 1 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>TDFA</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; (&#39;a :: finite) Al &#215; (&#39;b :: finite) Al &#8658; &#39;s &#215; bool &#215; bool &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>det</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q z x &#10233; &#948; q z x&#39; &#10233; x = x&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>finite_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite Q&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>init_in_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init &#8712; Q&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q &#10233; &#948; q z (q&#39;, b1, b2) &#10233; q&#39; &#8712; Q&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>move_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (a, b) (q&#39;, True, b2) &#10233; a &#8800; Blank&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>move_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (a, b) (q&#39;, b1, True) &#10233; b &#8800; Blank&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>no_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (a, b) (q&#39;, False, False) &#10233; a = Blank &#8743; b = Blank&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* notion of computation and computed relation *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>computation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a list &#215; &#39;b list &#8658; &#39;s &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_/&#8605;_/_&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>step_L</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb a, Blank) (q&#39;, True, False) &#10233; q&#39; &#8605;(as, []) q&#39;&#39; &#10233;
    q &#8605;(a # as, []) q&#39;&#39;&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>step_R</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Blank, Symb b) (q&#39;, False, True) &#10233; q&#39; &#8605;([], bs) q&#39;&#39; &#10233;
    q &#8605;([], b # bs) q&#39;&#39;&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>step_TT</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb a, Symb b) (q&#39;, True, True) &#10233;  q&#39; &#8605;(as, bs) q&#39;&#39; &#10233;
    q &#8605;(a # as, b # bs) q&#39;&#39;&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>step_TF</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb a, Symb b) (q&#39;, True, False) &#10233;  q&#39; &#8605;(as, b # bs) q&#39;&#39; &#10233;
    q &#8605;(a # as, b # bs) q&#39;&#39;&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>step_FT</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb a, Symb b) (q&#39;, False, True) &#10233;  q&#39; &#8605;(a # as, bs) q&#39;&#39; &#10233;
    q &#8605;(a # as, b # bs) q&#39;&#39;&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>last_step</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Blank, Blank) (q&#39;, False, False) &#10233; q &#8605;([], []) q&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>&#964;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a list &#215; &#39;b list) set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#964; = {(as, bs). &#8707;q. init &#8605;(as, bs) q &#8743; accept q}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TDFA moving exactly one head in every step used in the proof of Theorem 10 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>oTDFA</span><span> </span><span class="delimiter">=</span><span> </span><span>TDFA</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; (&#39;a :: finite) Al &#215; (&#39;b :: finite) Al &#8658; &#39;s &#215; bool &#215; bool &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>move_one</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;&#948; q (a, b) (q&#39;, True, True)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* lemmas *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>outs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a Al &#8658; &#39;s &#8658; (&#39;b &#215; &#39;s) list &#8658; &#39;s &#8658; &#39;b Al &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>outs_base</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb a, b) (q&#39;, True, False) &#10233; outs (Symb a) q [] q&#39; b&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>outs_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (a, Symb b&#39;) (q&#39;&#39;, False, True) &#10233; outs a q&#39;&#39; xs q&#39; b &#10233;
    outs a q ((b&#39;, q&#39;&#39;) # xs) q&#39; b&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>outs_last</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Blank, Blank) (q&#39;, False, False) &#10233; outs Blank q [] q Blank&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outs_drop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;outs a q (xs&#39; @ (b&#39;&#39;, q&#39;&#39;) # xs&#39;&#39;) q&#39; b &#10233; outs a q&#39;&#39; xs&#39;&#39; q&#39; b&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>a</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs&#39; @ (b&#39;&#39;, q&#39;&#39;) # xs&#39;&#39;&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>b</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>outs.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>outs_step</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>b&#39;</span><span> </span><span>q&#39;&#39;</span><span> </span><span>xs</span><span> </span><span>q&#39;</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outs_rem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;outs a q (xs @ (b&#39;, q&#39;&#39;) # xs&#39; @ (b&#39;&#39;, q&#39;&#39;) # xs&#39;&#39;) q&#39; b &#10233;
  outs a q (xs @ (b&#39;, q&#39;&#39;) # xs&#39;&#39;) q&#39; b&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>a</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs @ (b&#39;, q&#39;&#39;) # xs&#39; @ (b&#39;&#39;, q&#39;&#39;) # xs&#39;&#39;&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>b</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs</span><span>
</span><span>  </span><span>rule</span><span class="delimiter">:</span><span> </span><span>outs.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>outs_step</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>b&#39;</span><span> </span><span>q&#39;&#39;</span><span> </span><span>ixs</span><span> </span><span>q&#39;</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs_step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>outs.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>outs_step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>outs_step</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>outs_drop</span><span> </span><span>outs.outs_step</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outs_closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;outs a q xs q&#39; b &#10233; q &#8712; Q &#10233; (b&#39;, q&#39;&#39;) &#8712; set xs &#10233; q&#39;&#39; &#8712; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>a</span><span> </span><span>q</span><span> </span><span>xs</span><span> </span><span>q&#39;</span><span> </span><span>b</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>outs.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outs_closed&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;outs a q xs q&#39; b &#10233; q &#8712; Q &#10233; q&#39; &#8712; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>a</span><span> </span><span>q</span><span> </span><span>xs</span><span> </span><span>q&#39;</span><span> </span><span>b</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>outs.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outs_norm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;outs a q xs q&#39; b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs &gt; card Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;xs&#39;. outs a q xs&#39; q&#39; b &#8743; length xs&#39; &lt; length xs &#8743;
    safe_hd (map fst xs&#39;) = safe_hd (map fst xs)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>qs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs = map snd xs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>qs_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set qs &#8838; Q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_distinct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;distinct qs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;&#172;distinct qs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>contr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct qs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>card_qs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (set qs) &#8805; 1 + card Q&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>contr</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_qs</span><span> </span><span>card_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_Q</span><span> </span><span>qs_sub</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q&#39;&#39;</span><span> </span><span>qs&#39;</span><span> </span><span>qs&#39;&#39;</span><span> </span><span>qs&#39;&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs = qs&#39; @ [q&#39;&#39;] @ qs&#39;&#39; @ [q&#39;&#39;] @ qs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_distinct_decomp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>not_distinct</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>xs&#39;&#39;</span><span> </span><span>xs&#39;&#39;&#39;</span><span> </span><span>bs</span><span> </span><span>bs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs = xs&#39; @ (bs, q&#39;&#39;) # xs&#39;&#39; @ (bs&#39;, q&#39;&#39;) # xs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_ext</span><span class="delimiter">[</span><span>of</span><span> </span><span>snd</span><span> </span><span>xs</span><span> </span><span>qs&#39;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[q&#39;&#39;] @ qs&#39;&#39; @ [q&#39;&#39;] @ qs&#39;&#39;&#39;&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>map_ext</span><span class="delimiter">[</span><span>of</span><span> </span><span>snd</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[q&#39;&#39;] @ qs&#39;&#39;&#39;&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>outs&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;outs a q (xs&#39; @ (bs, q&#39;&#39;) # xs&#39;&#39; @ (bs&#39;, q&#39;&#39;) # xs&#39;&#39;&#39;) q&#39; b&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>decomp</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs_rem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>outs&#39;</span><span class="delimiter">]</span><span> </span><span>safe_hd_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>decomp</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>decomp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outs_Nil_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;outs Blank q xs q&#39;&#39; Blank &#10233; &#948; q&#39;&#39; (Blank, Blank) (q&#39;, False, False) &#10233;
  q &#8605;([], map fst xs) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Blank :: &#39;a Al&quot;</span></span></span><span> </span><span>q</span><span> </span><span>xs</span><span> </span><span>q&#39;&#39;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Blank :: &#39;b Al&quot;</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>outs.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outs_Nil_intro</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;([], bs) q&#39; &#10233; &#8707;xs q&#39;&#39;. outs Blank q xs q&#39;&#39; Blank &#8743;
  &#948; q&#39;&#39; (Blank, Blank) (q&#39;, False, False) &#8743; bs = map fst xs&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;([] :: &#39;a list, bs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_R</span><span> </span><span>q</span><span> </span><span>b</span><span> </span><span>q&#39;</span><span> </span><span>bs</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span>q&#39;&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>props</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;outs Blank q&#39; xs q&#39;&#39;&#39; Blank&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q&#39;&#39;&#39; (Blank, Blank) (q&#39;&#39;, False, False)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs = map fst xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_R</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_R</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>props</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>props</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>q&#39;&#39;&#39;</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(b, q&#39;) # xs&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>last_step</span><span> </span><span>q</span><span> </span><span>q&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs_last</span><span class="delimiter">[</span><span>OF</span><span> </span><span>last_step</span><span class="delimiter">]</span><span> </span><span>last_step</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outs_Cons_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;outs (Symb a) q xs q&#39;&#39; b &#10233; q&#39;&#39; &#8605;(as, bs&#39;) q&#39; &#10233;
  b = safe_hd bs&#39; &#10233; bs = map fst xs @ bs&#39; &#10233; q &#8605;(a # as, bs) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Symb a&quot;</span></span></span><span> </span><span>q</span><span> </span><span>xs</span><span> </span><span>q&#39;&#39;</span><span> </span><span>b</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>outs.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span> </span><span>Al.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outs_Cons_intro</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(a # as, bs) q&#39; &#10233; &#8707;xs q&#39;&#39; b &#946; bs&#39;. outs (Symb a) q xs q&#39;&#39; b &#8743;
  q&#39;&#39; &#8605;(as, bs&#39;) q&#39; &#8743; b = safe_hd bs&#39; &#8743; bs = map fst xs @ bs&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a # as, bs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_L</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>q&#39;</span><span> </span><span>as</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs_base</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_L</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>step_L</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_TT</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>q&#39;</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>move_one</span><span> </span><span>step_TT</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_TF</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>q&#39;</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs_base</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_TF</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>step_TF</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_FT</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>q&#39;</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q&#39;&#39;&#39;</span><span> </span><span>xs</span><span> </span><span>b&#39;</span><span> </span><span>bs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>props</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;outs (Symb a) q&#39; xs q&#39;&#39;&#39; b&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; = safe_hd bs&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs = map fst xs @ bs&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#39;&#39;&#8605;(as, bs&#39;)q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_FT</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_FT</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>props</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>props</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>q&#39;&#39;&#39;</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(b, q&#39;) # xs&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>b&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>reachable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a list &#8658; &#39;b list &#8658; &#39;a Al &#8658; &#39;b Al &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;reachable q as bs a b &#10231; q &#8712; Q &#8743; (&#8704;u v q&#39;. a = safe_hd u &#8743; b = safe_hd v &#8743;
    q &#8605;(u, v) q&#39; &#8743; accept q&#39; &#10230; (as @ u, bs @ v) &#8712; &#964;)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ext_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (a, b) (q&#39;, b1, b2) &#10233; q&#39; &#8605;(u, v) q&#39;&#39; &#10233; (&#172;b1 &#10233; a = safe_hd u) &#10233;
  (&#172;b2 &#10233; b = safe_hd v) &#10233; b1 &#8744; b2 &#10233;
  q &#8605;(if b1 then the_Symb a # u else u, if b2 then the_Symb b # v else v) q&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>the_Symb_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Al.splits</span><span> </span><span>list.splits</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">:</span><span> </span><span>move_left</span><span> </span><span>move_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachable_step</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (a, b) (q&#39;, b1, b2)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;reachable q as bs a b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b1 &#8744; b2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;reachable q&#39; (if b1 then as @ [the_Symb a] else as) (if b2 then bs @ [the_Symb b] else bs)
    (if b1 then a&#39; else a) (if b2 then b&#39; else b)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q&#39;_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39; &#8712; Q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>reach</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;u v q&#39;. a = safe_hd u &#10233; b = safe_hd v &#10233;
    q &#8605;(u, v) q&#39; &#10233; accept q&#39; &#10233; (as @ u, bs @ v) &#8712; &#964;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>True&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True&#39;</span><span> </span><span>True</span><span> </span><span>q&#39;_Q</span><span> </span><span>reach</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span> </span><span>safe_hd_def</span><span> </span><span>the_Symb_def</span><span>
</span><span>                 </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;as @ [the_Symb a]&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs @ [the_Symb b]&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>                 </span><span>dest</span><span class="delimiter">:</span><span> </span><span>ext_step</span><span> </span><span>move_left</span><span> </span><span>move_right</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>False</span><span> </span><span>q&#39;_Q</span><span> </span><span>reach</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span> </span><span>safe_hd_def</span><span> </span><span>the_Symb_def</span><span>
</span><span>                 </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;as @ [the_Symb a]&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>bs</span><span class="delimiter">]</span><span>
</span><span>                 </span><span>dest</span><span class="delimiter">:</span><span> </span><span>ext_step</span><span> </span><span>move_left</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>True</span><span> </span><span>q&#39;_Q</span><span> </span><span>reach</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span> </span><span>safe_hd_def</span><span> </span><span>the_Symb_def</span><span>
</span><span>                 </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>as</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs @ [the_Symb b]&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>                 </span><span>dest</span><span class="delimiter">:</span><span> </span><span>ext_step</span><span> </span><span>move_right</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outs_reachable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;outs (Symb a) q xs q&#39;&#39; b&#39;&#39; &#10233; (b = Blank &#10233; b&#39;&#39; = Blank) &#10233;
  reachable q as bs (Symb a) b &#10233;
  b = safe_hd (map fst xs @ (case b&#39;&#39; of Symb x &#8658; [x] | _ &#8658; [])) &#10233;
  reachable q&#39;&#39; (as @ [a]) (bs @ map fst xs) a&#39; b&#39;&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Symb a&quot;</span></span></span><span> </span><span>q</span><span> </span><span>xs</span><span> </span><span>q&#39;&#39;</span><span> </span><span>b&#39;&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>b</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>outs.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>outs_base</span><span> </span><span>q</span><span> </span><span>b&#39;</span><span> </span><span>q&#39;</span><span> </span><span>&#946;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>closed</span><span> </span><span>outs_base</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Al.splits</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>reachable_step</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>outs_step</span><span> </span><span>q</span><span> </span><span>b&#39;</span><span> </span><span>q&#39;&#39;</span><span> </span><span>xs</span><span> </span><span>q&#39;</span><span> </span><span>b&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b = Symb b&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs_step</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (map fst xs @ (case b&#39;&#39; of Symb x &#8658; [x] | Blank &#8658; [])) = Blank &#10233; b&#39;&#39; = Blank&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span> </span><span>Al.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs_step</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>reachable_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>outs_step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>outs_step</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>b_def</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>          </span><span>simplified</span><span class="delimiter">]</span><span> </span><span>refl</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachable_init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;reachable init [] [] a b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_in_Q</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span> </span><span>&#964;_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_suf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;reachable q as bs a b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a = safe_hd (u @ u1)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b = safe_hd v&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(u @ u1, v) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r cs y&#39; cs&#39;. reachable r (as @ u) (bs @ cs) (safe_hd u1) y&#39; &#8743;
    r &#8605;(u1, cs&#39;) q&#39; &#8743; v = cs @ cs&#39; &#8743; y&#39; = safe_hd cs&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length u + length v&quot;</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>nat_less_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>v</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>q</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>e</span><span> </span><span>u&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u = a&#39; # u&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a = Symb a&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Cons</span><span class="delimiter">]</span><span> </span><span>Cons</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;xa xb xc xd xe. length xa + length xb &lt; length u + length v &#10233;
      reachable xc xd xe (safe_hd (xa @ u1)) (safe_hd xb) &#10233; xc &#8605;(xa @ u1, xb) q&#39; &#10233;
      (&#8707;r cs y&#39; cs&#39;. reachable r (xd @ xa) (xe @ cs) (safe_hd u1) y&#39; &#8743; r &#8605;(u1, cs&#39;) q&#39; &#8743;
      xb = cs @ cs&#39; &#8743; y&#39; = safe_hd cs&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>comp</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>u_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b = Blank&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>Nil</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qm</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb a&#39;, Blank) (qm, True, False)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qm &#8605;(u&#39; @ u1, []) q&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>computation.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>comp</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Nil</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>reachable_qm</span><span> </span><span class="delimiter">=</span><span> </span><span>reachable_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>b_def</span><span> </span><span>u_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>of</span><span> </span><span>u&#39;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[]&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>Nil</span><span> </span><span>safe_hd_Nil</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>reachable_qm</span><span> </span><span>step</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u_def</span><span> </span><span>Nil</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>f</span><span> </span><span>v&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b = Symb f&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>safe_hd_v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd v = Symb f&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qm</span><span> </span><span>b1</span><span> </span><span>b2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb a&#39;, Symb f) (qm, b1, b2)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;qm &#8605;(if b1 then u&#39; @ u1 else a&#39; # u&#39; @ u1,
        if b2 then v&#39; else f # v&#39;) q&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>computation.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>comp</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Cons</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b_or</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b1 &#8744; b2&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>no_step</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>reachable_qm</span><span> </span><span class="delimiter">=</span><span> </span><span>reachable_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>b_def</span><span> </span><span>u_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>b_or</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>True&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>reach</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;reachable qm (as @ [a&#39;]) (bs @ [f]) (safe_hd (u&#39; @ u1)) (safe_hd v&#39;)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reachable_qm</span><span> </span><span>True&#39;</span><span> </span><span>True</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>of</span><span> </span><span>u&#39;</span><span> </span><span>v&#39;</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>reach</span><span class="delimiter">]</span><span> </span><span>step</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>True&#39;</span><span> </span><span>True</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>u_def</span><span> </span><span>Cons</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>reach</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;reachable qm (as @ [a&#39;]) bs (safe_hd (u&#39; @ u1)) (safe_hd v)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reachable_qm</span><span> </span><span>True&#39;</span><span> </span><span>False</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_v</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>of</span><span> </span><span>u&#39;</span><span> </span><span>v</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>reach</span><span class="delimiter">]</span><span> </span><span>step</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>True&#39;</span><span> </span><span>False</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>u_def</span><span> </span><span>Cons</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b_or</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>reach</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;reachable qm as (bs @ [f]) (safe_hd (u @ u1)) (safe_hd v&#39;)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reachable_qm</span><span> </span><span>False</span><span> </span><span>True</span><span> </span><span>u_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_v</span><span> </span><span>1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span>v&#39;</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>reach</span><span class="delimiter">]</span><span> </span><span>step</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>False</span><span> </span><span>True</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>u_def</span><span> </span><span>Cons</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>first_reaches</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;reachable q as bs (safe_hd (u @ u&#39;)) (safe_hd (v @ v&#39;))&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (u @ u&#39;) = safe_hd (u @ u&#39;&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd v&#39; = safe_hd v&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(u @ u&#39;, v @ v&#39;) q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(u @ u&#39;&#39;, v @ v&#39;&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;r cs c cs&#39;. reachable r (as @ u) (bs @ cs) (safe_hd u&#39;) c &#8743;
    r &#8605;(u&#39;, cs&#39; @ v&#39;) q&#39; &#8743; r &#8605;(u&#39;&#39;, cs&#39; @ v&#39;&#39;) q&#39;&#39; &#8743; cs @ cs&#39; = v &#8743;
    c = safe_hd (cs&#39; @ v&#39;) &#8743; c = safe_hd (cs&#39; @ v&#39;&#39;)) &#8744;
    (&#8707;r cs c cs&#39;. reachable r (as @ cs) (bs @ v) c (safe_hd v&#39;) &#8743;
    r &#8605;(cs&#39; @ u&#39;, v&#39;) q&#39; &#8743; r &#8605;(cs&#39; @ u&#39;&#39;, v&#39;&#39;) q&#39;&#39; &#8743; cs @ cs&#39; = u &#8743;
    c = safe_hd (cs&#39; @ u&#39;) &#8743; c = safe_hd (cs&#39; @ u&#39;&#39;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length u + length v&quot;</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span>q</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>nat_less_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x xa xb xc xd xe xf.
    length x + length xa &lt; length u + length v &#10233;
    reachable xb xc xd (safe_hd (x @ u&#39;)) (safe_hd (xa @ v&#39;)) &#10233;
    safe_hd (x @ u&#39;) = safe_hd (x @ u&#39;&#39;) &#10233;
    xb&#8605;(x @ u&#39;, xa @ v&#39;)q&#39; &#10233; xb&#8605;(x @ u&#39;&#39;, xa @ v&#39;&#39;)q&#39;&#39; &#10233;
    (&#8707;r cs c cs&#39;. reachable r (xc @ x) (xd @ cs) (safe_hd u&#39;) c &#8743;
      r&#8605;(u&#39;, cs&#39; @ v&#39;)q&#39; &#8743; r&#8605;(u&#39;&#39;, cs&#39; @ v&#39;&#39;)q&#39;&#39; &#8743; cs @ cs&#39; = xa &#8743;
      c = safe_hd (cs&#39; @ v&#39;) &#8743; c = safe_hd (cs&#39; @ v&#39;&#39;)) &#8744;
    (&#8707;r cs c cs&#39;.
      reachable r (xc @ cs) (xd @ xa) c (safe_hd v&#39;) &#8743;
      r&#8605;(cs&#39; @ u&#39;, v&#39;)q&#39; &#8743; r&#8605;(cs&#39; @ u&#39;&#39;, v&#39;&#39;)q&#39;&#39; &#8743; cs @ cs&#39; = x &#8743;
      c = safe_hd (cs&#39; @ u&#39;) &#8743; c = safe_hd (cs&#39; @ u&#39;&#39;))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>1</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">,</span><span>5</span><span class="delimiter">,</span><span>6</span><span class="delimiter">)</span><span> </span><span>safe_hd_app&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Nil</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>q</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[]&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>b</span><span> </span><span>b&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Cons&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>Cons</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">,</span><span>6</span><span class="delimiter">)</span><span> </span><span>safe_hd_app&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Nil</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>q</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[]&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>a&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Cons&#39;&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>Cons</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>symbs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (a # a&#39; @ u&#39;) = Symb a&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (b # b&#39; @ v&#39;) = Symb b&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qm</span><span> </span><span>b1</span><span> </span><span>b2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb a, Symb b) (qm, b1, b2)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;qm &#8605;((if b1 then a&#39; else a # a&#39;) @ u&#39;, (if b2 then b&#39; else b # b&#39;) @ v&#39;) q&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>computation.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Cons&#39;</span><span> </span><span>Cons</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qm &#8605;((if b1 then a&#39; else a # a&#39;) @ u&#39;&#39;, (if b2 then b&#39; else b # b&#39;) @ v&#39;&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>computation.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>det</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons&#39;</span><span> </span><span>Cons</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b_props</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b1 &#8744; b2&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(b1 &#8743; b2)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>move_one</span><span> </span><span>no_step</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>reach</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;reachable q as bs (Symb a) (Symb b)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons&#39;</span><span> </span><span>Cons</span><span> </span><span>symbs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>reach&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>reachable_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>reach</span><span> </span><span>b_props</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b_props</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a&#39;</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI1</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>step</span><span> </span><span>step&#39;</span><span> </span><span>reach&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd u&#39;&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>True</span><span> </span><span>False</span><span>
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cons&#39;</span><span> </span><span>Cons&#39;&#39;</span><span> </span><span>Nil</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>qm</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[]&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>c</span><span> </span><span>c&#39;</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;r cs c cs&#39;. reachable r ((as @ [a]) @ a&#39;) (bs @ cs) (safe_hd u&#39;) c &#8743;
                r&#8605;(u&#39;, cs&#39; @ v&#39;)q&#39; &#8743; r&#8605;(u&#39;&#39;, cs&#39; @ v&#39;&#39;)q&#39;&#39; &#8743; cs @ cs&#39; = b # b&#39; &#8743;
                c = safe_hd (cs&#39; @ v&#39;) &#8743; c = safe_hd (cs&#39; @ v&#39;&#39;)) &#8744;
              (&#8707;r cs c cs&#39;.
                reachable r ((as @ [a]) @ cs) (bs @ b # b&#39;) c (safe_hd v&#39;) &#8743;
                r&#8605;(cs&#39; @ u&#39;, v&#39;)q&#39; &#8743; r&#8605;(cs&#39; @ u&#39;&#39;, v&#39;&#39;)q&#39;&#39; &#8743; cs @ cs&#39; = a&#39; &#8743;
                c = safe_hd (cs&#39; @ u&#39;) &#8743; c = safe_hd (cs&#39; @ u&#39;&#39;))&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>of</span><span> </span><span>a&#39;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b # b&#39;&quot;</span></span></span><span> </span><span>qm</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;as @ [a]&quot;</span></span></span><span> </span><span>bs</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>Cons&#39;</span><span> </span><span>Cons</span><span class="delimiter">]</span><span>
</span><span>                    </span><span>reach&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (a&#39; @ u&#39;)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>step</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>step&#39;</span><span> </span><span>True</span><span> </span><span>False</span><span>
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cons</span><span> </span><span>Cons&#39;</span><span> </span><span>Cons&#39;&#39;</span><span> </span><span>symbs</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI1</span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons&#39;</span><span> </span><span>Cons&#39;&#39;</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons&#39;</span><span> </span><span>Cons&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b_props</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>safe_hd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd ((a # a&#39;) @ u&#39;) = safe_hd ((a # a&#39;) @ u&#39;&#39;)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;r cs c cs&#39;. reachable r (as @ a # a&#39;) ((bs @ [b]) @ cs) (safe_hd u&#39;) c &#8743;
              r&#8605;(u&#39;, cs&#39; @ v&#39;)q&#39; &#8743; r&#8605;(u&#39;&#39;, cs&#39; @ v&#39;&#39;)q&#39;&#39; &#8743; cs @ cs&#39; = b&#39; &#8743;
              c = safe_hd (cs&#39; @ v&#39;) &#8743; c = safe_hd (cs&#39; @ v&#39;&#39;)) &#8744;
            (&#8707;r cs c cs&#39;.
              reachable r (as @ cs) ((bs @ [b]) @ b&#39;) c (safe_hd v&#39;) &#8743;
              r&#8605;(cs&#39; @ u&#39;, v&#39;)q&#39; &#8743; r&#8605;(cs&#39; @ u&#39;&#39;, v&#39;&#39;)q&#39;&#39; &#8743; cs @ cs&#39; = a # a&#39; &#8743;
              c = safe_hd (cs&#39; @ u&#39;) &#8743; c = safe_hd (cs&#39; @ u&#39;&#39;))&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a # a&#39;&quot;</span></span></span><span> </span><span>b&#39;</span><span> </span><span>qm</span><span> </span><span>as</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs @ [b]&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>Cons&#39;</span><span> </span><span>Cons</span><span class="delimiter">]</span><span>
</span><span>                  </span><span>reach&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (b&#39; @ v&#39;)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>safe_hd</span><span> </span><span>step</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>step&#39;</span><span> </span><span>False</span><span> </span><span>True</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons&#39;</span><span> </span><span>Cons</span><span> </span><span>symbs</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI1</span><span class="delimiter">)</span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons&#39;</span><span> </span><span>Cons</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons&#39;</span><span> </span><span>Cons</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* simulating any TDFA by an oTDFA *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;s</span><span> </span><span>otdfa_s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s + &#39;s&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>TDFA</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>otdfa_init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s otdfa_s&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_init = Inl init&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>otdfa_delta</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s otdfa_s &#8658; &#39;a Al &#215; &#39;b Al &#8658; &#39;s otdfa_s &#215; bool &#215; bool &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (a, b) (q&#39;, b1, b2) &#10233; &#172;(b1 &#8743; b2) &#10233; otdfa_delta (Inl q) (a, b) (Inl q&#39;, b1, b2)&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (a, b) (q&#39;, True, True) &#10233; otdfa_delta (Inl q) (a, b) (Inr q&#39;, True, False)&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_delta (Inr q) (a, Symb b) (Inl q, False, True)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>otdfa_accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s otdfa_s &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_accept q = (case q of Inl q&#39; &#8658; accept q&#39; | _ &#8658; False)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>otdfa_Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s otdfa_s set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_Q = Inl ` Q &#8746; Inr ` Q&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_det</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_delta q z x&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_delta q z x&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = x&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>otdfa_delta.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>rule</span><span> </span><span>otdfa_delta.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>det</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_finite_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite otdfa_Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_Q</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>otdfa_Q_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_init_in_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_init &#8712; otdfa_Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_in_Q</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>otdfa_init_def</span><span> </span><span>otdfa_Q_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_closed</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_delta q z (q&#39;, b1, b2)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; otdfa_Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39; &#8712; otdfa_Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>otdfa_delta.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>otdfa_Q_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_move_left</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_delta q (a, b) (q&#39;, True, b2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8800; Blank&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>otdfa_delta.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>move_left</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_move_right</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_delta q (a, b) (q&#39;, b1, True)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8800; Blank&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>otdfa_delta.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>move_right</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_no_step</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_delta q (a, b) (q&#39;, False, False)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a = Blank &#8743; b = Blank&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>otdfa_delta.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_move_one</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_delta q (a, b) (q&#39;, True, True)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>otdfa_delta.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>otdfa</span><span class="delimiter">:</span><span> </span><span>oTDFA</span><span> </span><span>otdfa_init</span><span> </span><span>otdfa_delta</span><span> </span><span>otdfa_accept</span><span> </span><span>otdfa_Q</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>otdfa_det</span><span> </span><span>otdfa_finite_Q</span><span> </span><span>otdfa_init_in_Q</span><span> </span><span>otdfa_closed</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span>
</span><span>        </span><span>otdfa_move_left</span><span> </span><span>otdfa_move_right</span><span> </span><span>otdfa_no_step</span><span> </span><span>otdfa_move_one</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tdfa_comp_otdfa</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa.computation (Inl q) (as, bs) (Inl q&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_TT</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>q&#39;</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_TT</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>          </span><span>otdfa.computation.step_TF</span><span class="delimiter">[</span><span>OF</span><span> </span><span>otdfa_delta.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_TT</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>            </span><span>otdfa.computation.step_FT</span><span class="delimiter">[</span><span>OF</span><span> </span><span>otdfa_delta.intros</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>          </span><span>otdfa.computation.step_TF</span><span class="delimiter">[</span><span>OF</span><span> </span><span>otdfa_delta.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_TT</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>            </span><span>otdfa.computation.step_R</span><span class="delimiter">[</span><span>OF</span><span> </span><span>otdfa_delta.intros</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>as</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>otdfa_delta.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_comp_tdfa</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa.computation r (as, bs) (Inl q&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;r = Inl q &#8744; (r = Inr q&#39;&#39; &#8743; &#948; q (Symb a, safe_hd bs) (q&#39;&#39;, True, True))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(if r = Inr q&#39;&#39; then a # as else as, bs) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>r</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Inl q&#39; :: &#39;s otdfa_s&quot;</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>q&#39;</span><span> </span><span>a</span><span> </span><span>q&#39;&#39;</span><span>
</span><span>  </span><span>rule</span><span class="delimiter">:</span><span> </span><span>otdfa.computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_L</span><span> </span><span>r</span><span> </span><span>a</span><span> </span><span>r&#39;</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_L</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>r&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Inr</span><span> </span><span>r&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_L</span><span> </span><span>move_right</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Inr</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>otdfa_delta.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>otdfa_delta.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_R</span><span> </span><span>r</span><span> </span><span>b&#39;</span><span> </span><span>r&#39;</span><span> </span><span>bs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_R</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>r&#39;</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>otdfa_delta.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_TF</span><span> </span><span>r</span><span> </span><span>a&#39;</span><span> </span><span>b&#39;</span><span> </span><span>r&#39;</span><span> </span><span>as</span><span> </span><span>bs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_TF</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>r&#39;</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>otdfa_delta.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_FT</span><span> </span><span>r</span><span> </span><span>a&#39;</span><span> </span><span>b&#39;</span><span> </span><span>r&#39;</span><span> </span><span>as</span><span> </span><span>bs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_FT</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>r&#39;</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>otdfa_delta.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>otdfa_delta.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tdfa_otdfa_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10231; otdfa.computation (Inl q) (as, bs) (Inl q&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tdfa_comp_otdfa</span><span> </span><span>otdfa_comp_tdfa</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tdfa_equiv_otdfa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#964; = otdfa.&#964;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>&#964;_def</span><span> </span><span>otdfa.&#964;_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>otdfa_init_def</span><span> </span><span>otdfa_accept_def</span><span> </span><span>tdfa_otdfa_comp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>sum.splits</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>obj_sumE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* functional automata *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>fTDFA</span><span> </span><span class="delimiter">=</span><span> </span><span>TDFA</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; (&#39;a :: finite) Al &#215; (&#39;b :: finite) Al &#8658; &#39;s &#215; bool &#215; bool &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>functional</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs) &#8712; &#964; &#10233; (as, bs&#39;) &#8712; &#964; &#10233; bs = bs&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>foTDFA</span><span> </span><span class="delimiter">=</span><span> </span><span>oTDFA</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; (&#39;a :: finite) Al &#215; (&#39;b :: finite) Al &#8658; &#39;s &#215; bool &#215; bool &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>functional</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs) &#8712; &#964; &#10233; (as, bs&#39;) &#8712; &#964; &#10233; bs = bs&#39;&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lin_bounded</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;reachable q as bs a b &#10233; q &#8605;(u, v) q&#39; &#10233; accept q&#39; &#10233;
  a = safe_hd u &#10233; b = safe_hd v &#10233; length v &#8804; (length u + 1) * card Q&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>u</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>q</span><span> </span><span>v</span><span> </span><span>q&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nil</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>reach</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;u v q&#39;. a = safe_hd u &#10233; b = safe_hd v &#10233;
    q &#8605;(u, v) q&#39; &#10233; accept q&#39; &#10233; (as @ u, bs @ v) &#8712; &#964;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nil</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span>q&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>outs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;outs Blank q xs q&#39;&#39; Blank&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q&#39;&#39; (Blank, Blank) (q&#39;, False, False)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v = map fst xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs_Nil_intro</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Nil</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs &gt; card Q&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;outs Blank q xs&#39; q&#39;&#39; Blank&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs&#39; &lt; length xs&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (map fst xs&#39;) = safe_hd (map fst xs)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs_norm</span><span class="delimiter">[</span><span>OF</span><span> </span><span>outs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>q_Q</span><span> </span><span>True</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs @ v) &#8712; &#964;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reach</span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs @ map fst xs&#39;) &#8712; &#964;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reach</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Nil</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>outs_Nil_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>xs&#39;_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>outs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>Nil</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>            </span><span>Nil</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>outs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>xs&#39;_def</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>functional</span><span> </span><span>map_eq_imp_length_eq</span><span> </span><span>xs&#39;_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>outs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a&#39;</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>reach</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;u v q&#39;. a = safe_hd u &#10233; b = safe_hd v &#10233;
    q &#8605;(u, v) q&#39; &#10233; accept q&#39; &#10233; (as @ u, bs @ v) &#8712; &#964;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reachable_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span>q&#39;&#39;</span><span> </span><span>b&#39;&#39;</span><span> </span><span>bs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>outs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;outs (Symb a&#39;) q xs q&#39;&#39; b&#39;&#39;&quot;</span></span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#39;&#8605;(u, bs&#39;)q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39;&#39; = safe_hd bs&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v = map fst xs @ bs&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs_Cons_intro</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (map fst xs @ (case b&#39;&#39; of Symb x &#8658; [x] | Blank &#8658; [])) = Blank &#10233;
    b&#39;&#39; = Blank&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span> </span><span>Al.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a = Symb a&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>safe_hd_v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd v = safe_hd (map fst xs @ (case b&#39;&#39; of Symb x &#8658; [x] | Blank &#8658; []))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span> </span><span>Al.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs &gt; card Q &#10233; False&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>lassm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs &gt; card Q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;outs (Symb a&#39;) q xs&#39; q&#39;&#39; b&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs&#39; &lt; length xs&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (map fst xs&#39;) = safe_hd (map fst xs)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs_norm</span><span class="delimiter">[</span><span>OF</span><span> </span><span>outs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>q_Q</span><span> </span><span>lassm</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as @ a&#39; # u, bs @ v) &#8712; &#964;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reach</span><span> </span><span>Cons</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as @ a&#39; # u, bs @ map fst xs&#39; @ bs&#39;) &#8712; &#964;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reach</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>outs_Cons_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>xs&#39;_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>outs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">,</span><span>
</span><span>            </span><span>unfolded</span><span> </span><span>safe_hd_app</span><span class="delimiter">[</span><span>OF</span><span> </span><span>xs&#39;_def</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>bs&#39;</span><span class="delimiter">]</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>outs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>functional</span><span> </span><span>xs&#39;_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>map_eq_imp_length_eq</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>outs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>outs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>refl</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>outs_reachable</span><span class="delimiter">[</span><span>OF</span><span> </span><span>outs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>refl</span><span class="delimiter">,</span><span>
</span><span>          </span><span>OF</span><span> </span><span>aux</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>a_def</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>safe_hd_v</span><span class="delimiter">]</span><span> </span><span>outs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>outs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Definition 2 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>NFT</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a :: finite &#8658; &#39;s &#215; (&#39;b :: finite) list &#8658; bool&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>finite_&#948;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q &#10233; finite {x. &#948; q a x}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>init_in_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init &#8712; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;_closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q &#10233; &#948; q a (q&#39;, bs) &#10233; q&#39; &#8712; Q&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* notion of computation and computed relation *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>computation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a list &#215; &#39;b list &#8658; &#39;s &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_/&#8605;_/_&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>base</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;([], []) q&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>step</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q a (q&#39;, bs) &#10233; q&#39; &#8605;(as, bs&#39;) q&#39;&#39; &#10233; q &#8605;(a # as, bs @ bs&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>&#964;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a list &#215; &#39;b list) set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#964; = {(as, bs). &#8707;q. init &#8605;(as, bs) q &#8743; accept q}&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Bounded trailing *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>active</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;b list &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;active q bs &#10231; (&#8707;q&#39; as bs&#39;. q &#8605;(as, bs @ bs&#39;) q&#39; &#8743; accept q&#39;)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bounded K &#8801; &#8704;q q&#39; u v v&#39;. init &#8605;(u, v @ v&#39;) q &#8743; active q [] &#8743;
  init &#8605;(u, v) q&#39; &#8743; active q&#39; v&#39; &#10230; length v&#39; &#8804; K&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* helper lemmas *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233; as = [] &#10233; bs = [] &#8743; q = q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q a (q&#39;, bs) &#10233; q &#8605;([a], bs) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation.step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;([a], bs) q&#39; &#10233; &#948; q a (q&#39;, bs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;([a], bs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation.cases</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233; q&#39; &#8605;(as&#39;, bs&#39;) q&#39;&#39; &#10233; q &#8605;(as @ as&#39;, bs @ bs&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_snoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233; &#948; q&#39; a (q&#39;&#39;, bs&#39;) &#10233; q &#8605;(as @ [a], bs @ bs&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q&#39; a (q&#39;&#39;, bs&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39; &#8605;([a], bs&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as @ [a], bs @ bs&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as @ as&#39;, bs&#39;&#39;) q&#39; &#10233;
  &#8707;q&#39;&#39; bs bs&#39;. q &#8605;(as, bs) q&#39;&#39; &#8743; q&#39;&#39; &#8605;(as&#39;, bs&#39;) q&#39; &#8743; bs&#39;&#39; = bs @ bs&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as @ as&#39;, bs&#39;&#39;)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>as&#39;</span><span> </span><span>bs&#39;&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>q&#39;</span><span> </span><span>bs</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>asa</span><span> </span><span>bs&#39;</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>step</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>xs</span><span> </span><span>as&#39;</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_rev_induct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#8605;(as, bs) q&#39; &#10233;
  (&#8896;q. P q [] [] q) &#10233;
  (&#8896;q a q&#39; bs as bs&#39; q&#39;&#39;. P q as bs q&#39;&#39; &#10233; q&#8605;(as, bs)q&#39;&#39; &#10233; &#948; q&#39;&#39; a (q&#39;, bs&#39;) &#10233;
    P q (as @ [a]) (bs @ bs&#39;) q&#39;) &#10233;
  P q as bs q&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>as</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q</span><span> </span><span>bs</span><span> </span><span>q&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_step</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>snoc</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q&#39;&#39;</span><span> </span><span>cs</span><span> </span><span>cs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(xs, cs) q&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#39; &#8605;([x], cs&#39;) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs = cs @ cs&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>snoc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P_xs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P q xs cs q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snoc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>snoc</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snoc</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>P_xs</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>step_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233; q &#8712; Q &#10233; q&#39; &#8712; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>&#948;_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>computation_ext</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a list &#215; (&#39;s &#215; &#39;b list) list &#8658; &#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_/&#8605;e_/_&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>base_ext</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e([], []) q&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>step_ext</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q a (q&#39;, bs) &#10233; q&#39; &#8605;e(as, qs) q&#39;&#39; &#10233; q &#8605;e(a # as, (q&#39;, bs) # qs) q&#39;&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_no_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e([], []) q&#39; &#10233; q = q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>computation_ext.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_Cons_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#8605;e(a # as&#39;, qb # qbs&#39;)q&#39; &#10233; &#948; q a qb&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>computation_ext.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as, qs) q&#39; &#10233; q&#39; &#8605;e(as&#39;, qs&#39;) q&#39;&#39; &#10233;
  q &#8605;e(as @ as&#39;, qs @ qs&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, qs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>qs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation_ext.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as, qs) q&#39; &#10233; length qs = length as&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, qs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>qs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation_ext.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_sound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as, qs) q&#39; &#10233; q &#8605;(as, concat (map snd qs)) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, qs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>qs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation_ext.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_complete</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233;
  &#8707;qs. q &#8605;e(as, qs) q&#39; &#8743; bs = concat (map snd qs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as = length qbs &#10233;
  q &#8605;e(as @ a # as&#39;, qbs @ (q&#39;&#39;, bs) # qbs&#39;) q&#39; &#10233;
  q &#8605;e(as @ [a], qbs @ [(q&#39;&#39;, bs)]) q&#39;&#39; &#8743; q&#39;&#39; &#8605;e(as&#39;, qbs&#39;) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>as</span><span> </span><span>qbs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_induct2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>computation_ext.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as, qs) q&#39; &#10233; q &#8712; Q &#10233; (r, bs) &#8712; set qs &#10233; r &#8712; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, qs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>qs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation_ext.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>&#948;_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>all_trans</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s &#215; &#39;b list) set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;all_trans = {x. &#8707;(q, a) &#8712; (Q &#215; (UNIV :: &#39;a set)). &#948; q a x}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_trans_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite all_trans&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fin_Q_UNIV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (Q &#215; (UNIV :: &#39;a set))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_Q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_trans &#8838; &#8899;((&#955;(q, a). {x. &#948; q a x}) ` (Q &#215; (UNIV :: &#39;a set)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_trans_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (&#8899;((&#955;(q, a). {x. &#948; q a x}) ` (Q &#215; (UNIV :: &#39;a set))))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fin_Q_UNIV</span><span> </span><span>finite_&#948;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>infinite_super</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_trans_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q &#10233; &#948; q a x &#10233; x &#8712; all_trans&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_trans_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Definition 5 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>output_speed</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;output_speed = Max (length ` snd ` all_trans &#8746; {1})&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>output_speed_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q &#10233; &#948; q a (q&#39;, bs) &#10233; length bs &#8804; output_speed&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>output_speed_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_trans_finite</span><span> </span><span>all_trans_step</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Max_ge</span><span> </span><span>UnCI</span><span> </span><span>finite.emptyI</span><span> </span><span>finite.insertI</span><span> </span><span>finite_UnI</span><span> </span><span>finite_imageI</span><span> </span><span>image_eqI</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>output_speed_computation</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233; q &#8712; Q &#10233;
  length bs &#8804; length as * output_speed&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>output_speed_step</span><span> </span><span>&#948;_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_le_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>output_speed_ext_computation</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as, qbs) q&#39; &#10233; q &#8712; Q &#10233; (q&#39;&#39;, bs) &#8712; set qbs &#10233;
  length bs &#8804; output_speed&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, qbs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>qbs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation_ext.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>output_speed_step</span><span> </span><span>&#948;_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>output_speed_pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;output_speed &#8805; 1&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (length ` snd ` all_trans &#8746; {1})&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_trans_finite</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Max_ge</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fin</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>output_speed_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_split_out</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as&#39;&#39;, bs @ bs&#39;) q&#39; &#10233; q &#8712; Q &#10233;
  &#8707;q&#39;&#39; as as&#39; cs cs&#39;. q &#8605;(as, cs) q&#39;&#39; &#8743; q&#39;&#39; &#8605;(as&#39;, cs&#39;) q&#39; &#8743; as&#39;&#39; = as @ as&#39; &#8743;
    bs @ bs&#39; = cs @ cs&#39; &#8743; length cs &#8804; length bs &#8743; length bs - length cs &#8804; output_speed&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as&#39;&#39;, bs @ bs&#39;)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as&#39;&#39;</span><span> </span><span>bs</span><span> </span><span>bs&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>q&#39;</span><span> </span><span>bsa</span><span> </span><span>as</span><span> </span><span>bsa&#39;</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>length_bsa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bsa &#8804; output_speed&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>output_speed_step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bsa &#8804; length bs&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>step</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bsa&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs = bsa @ bsa&#39;&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_eq_append_conv_if</span><span> </span><span>append_eq_conv_conj</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span>step</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>bsa&#39;&#39;</span><span> </span><span>bs&#39;</span><span class="delimiter">]</span><span> </span><span>&#948;_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>step</span><span> </span><span>length_bsa</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#8605;([], [])q &#8743; q&#8605;(a # as, bsa @ bsa&#39;)q&#39;&#39; &#8743; a # as = [] @ (a # as) &#8743;
      bs @ bs&#39; = [] @ (bsa @ bsa&#39;) &#8743; length [] &#8804; length bs &#8743; length bs - length [] &#8804; output_speed&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation.step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_rem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as, qbs&#39; @ (q&#39;, bs) # qbs&#39;&#39; @ (q&#39;, bs&#39;) # qbs&#39;&#39;&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;cs&#39; cs&#39;&#39; cs&#39;&#39;&#39; c&#39; c&#39;&#39; bs&#39; bs&#39;&#39;&#39;.
    q &#8605;(cs&#39; @ c&#39; # cs&#39;&#39;&#39;, bs&#39; @ bs @ bs&#39;&#39;&#39;) q&#39;&#39; &#8743;
    bs&#39; = concat (map snd qbs&#39;) &#8743; bs&#39;&#39;&#39; = concat (map snd qbs&#39;&#39;&#39;) &#8743;
    as = cs&#39; @ c&#39; # cs&#39;&#39; @ c&#39;&#39; # cs&#39;&#39;&#39; &#8743; length cs&#39; = length qbs&#39; &#8743;
    length cs&#39;&#39; = length qbs&#39;&#39; &#8743; length cs&#39;&#39;&#39; = length qbs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>len_as</span><span> </span><span class="delimiter">=</span><span> </span><span>computation_ext_length</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as&#39;</span><span> </span><span>as&#39;&#39;</span><span> </span><span>as&#39;&#39;&#39;</span><span> </span><span>a</span><span> </span><span>a&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>decomp&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;as = as&#39; @ [a] @ as&#39;&#39; @ [a&#39;] @ as&#39;&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as&#39; = length qbs&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length as&#39;&#39; = length qbs&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as&#39;&#39;&#39; = length qbs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>app_decomp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>len_as</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>app_decomp</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[(q&#39;, bs)]&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qbs&#39;&#39; @ [(q&#39;, bs&#39;)] @ qbs&#39;&#39;&#39;&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>        </span><span>app_decomp</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>qbs&#39;&#39;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[(q&#39;, bs&#39;)] @ qbs&#39;&#39;&#39;&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>        </span><span>app_decomp</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[(q&#39;, bs&#39;)]&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qbs&#39;&#39;&#39;&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>        </span><span>singleton_dest</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as&#39; @ a # as&#39;&#39; @ [a&#39;] @ as&#39;&#39;&#39;,
    qbs&#39; @ (q&#39;, bs) # qbs&#39;&#39; @ [(q&#39;, bs&#39;)] @ qbs&#39;&#39;&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>decomp&#39;</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as&#39; @ [a], qbs&#39; @ [(q&#39;, bs)]) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#8605;e(as&#39;&#39; @ a&#39; # as&#39;&#39;&#39;,
    qbs&#39;&#39; @ (q&#39;, bs&#39;) # qbs&#39;&#39;&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_ext_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>decomp&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assoc</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>split&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39; &#8605;e(as&#39;&#39;&#39;, qbs&#39;&#39;&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_ext_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>decomp&#39;</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>bs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs&#39; = concat (map snd qbs&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>bs&#39;&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs&#39;&#39;&#39; = concat (map snd qbs&#39;&#39;&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as&#39; @ [a], bs&#39; @ bs) q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_ext_sound</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bs&#39;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>trans&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39; &#8605;(as&#39;&#39;&#39;, bs&#39;&#39;&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_ext_sound</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split&#39;</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bs&#39;&#39;&#39;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>trans</span><span> </span><span>trans&#39;</span><span class="delimiter">]</span><span> </span><span>decomp&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bs&#39;_def</span><span> </span><span>bs&#39;&#39;&#39;_def</span><span> </span><span>decomp&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_long_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233; q &#8712; Q &#10233; length as &#8805; 1 + card Q &#10233;
  &#8707;as&#39; bs&#39;. q &#8605;(as&#39;, bs&#39;) q&#39; &#8743; length as&#39; &lt; length as&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assms_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qbs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>qbs_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as, qbs) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs = concat (map snd qbs)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_ext_complete</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms_comp</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>qbs_len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs = length as&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_ext_length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assms_len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as &#8805; 1 + card Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>qs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs = map fst qbs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>qs_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set qs &#8838; Q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_ext_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>qbs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms_comp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_distinct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;distinct qs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;&#172;distinct qs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>contr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct qs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>card_qs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (set qs) &#8805; 1 + card Q&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>contr</span><span class="delimiter">]</span><span> </span><span>assms_len</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span> </span><span>qbs_len</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_qs</span><span> </span><span>card_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_Q</span><span> </span><span>qs_sub</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q&#39;&#39;</span><span> </span><span>qs&#39;</span><span> </span><span>qs&#39;&#39;</span><span> </span><span>qs&#39;&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs = qs&#39; @ [q&#39;&#39;] @ qs&#39;&#39; @ [q&#39;&#39;] @ qs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_distinct_decomp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>not_distinct</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qbs&#39;</span><span> </span><span>qbs&#39;&#39;</span><span> </span><span>qbs&#39;&#39;&#39;</span><span> </span><span>bs</span><span> </span><span>bs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qbs = qbs&#39; @ (q&#39;&#39;, bs) # qbs&#39;&#39; @ (q&#39;&#39;, bs&#39;) # qbs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_ext</span><span class="delimiter">[</span><span>of</span><span> </span><span>fst</span><span> </span><span>qbs</span><span> </span><span>qs&#39;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[q&#39;&#39;] @ qs&#39;&#39; @ [q&#39;&#39;] @ qs&#39;&#39;&#39;&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>map_ext</span><span class="delimiter">[</span><span>of</span><span> </span><span>fst</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[q&#39;&#39;] @ qs&#39;&#39;&#39;&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;as&#39; bs&#39;. q &#8605;(as&#39;, bs&#39;) q&#39; &#8743; length as&#39; &lt; length as&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_ext_rem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>qbs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>decomp</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_norm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233; q &#8712; Q &#10233; &#8707;as&#39; bs&#39;. q &#8605;(as&#39;, bs&#39;) q&#39; &#8743; length as&#39; &#8804; card Q&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as&quot;</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>nat_less_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as &#8804; card Q&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as&#39;</span><span> </span><span>bs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>nex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as&#39;, bs&#39;) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as&#39; &lt; length as&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_long_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pumping</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q &#10233; q &#8605;(iter_concat n as, iter_concat n bs) q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>comp_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>active_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;active q&#39; bs &#10233; q &#8605;(as, bs&#39;) q&#39; &#10233; active q (bs&#39; @ bs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_trans</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>active_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>active_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;active q (bs @ bs&#39;) &#10233; active q bs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>active_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>active_extend</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs @ bs&#39;) q&#39; &#10233; active q&#39; bs &#10233; active q bs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>active_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>active_Nil_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;active q [] &#10233; q &#8712; Q &#10233;
  &#8707;as bs&#39; q&#39;. q &#8605;(as, bs&#39;) q&#39; &#8743; accept q&#39; &#8743; length as &#8804; card Q &#8743;
    length bs&#39; &#8804; card Q * output_speed&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_norm</span><span> </span><span>output_speed_computation</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>active_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>dual_order.trans</span><span> </span><span>mult_le_mono1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Definition 4 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sg</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sg = Max ((&#955;q. Inf (length ` {as. &#8707;bs q&#39;. q &#8605;(as, bs) q&#39; &#8743; accept q&#39;})) `
    {q &#8712; Q. active q []})&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sg_le_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;active init []&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sg &#8804; card Q&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>Q&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q&#39; = {q &#8712; Q. active q []}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Q&#39;_props</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite Q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q&#39; &#8800; {}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_Q</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>init_in_Q</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>active_def</span><span> </span><span>Q&#39;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;q. q &#8712; Q&#39; &#10233; Inf (length ` {as. &#8707;bs q&#39;. q&#8605;(as, bs)q&#39; &#8743; accept q&#39;}) &#8804; card Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>q</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>in_Q&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>q&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>wit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#8605;(as, bs)q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;accept q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as &#8804; card Q&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>active_Nil_dest</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Q&#39;_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_as_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as &#8712; length ` {as. &#8707;bs q&#39;. q&#8605;(as, bs)q&#39; &#8743; accept q&#39;}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Inf (length ` {as. &#8707;bs q&#39;. q&#8605;(as, bs)q&#39; &#8743; accept q&#39;}) &#8804; card Q&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>le_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cInf_lower</span><span class="delimiter">[</span><span>OF</span><span> </span><span>len_as_in</span><span class="delimiter">]</span><span> </span><span>wit</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Q&#39;_props</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sg_def</span><span> </span><span>Q&#39;_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>active_Nil_dest_sg</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;active q []&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;as bs&#39; q&#39;. q &#8605;(as, bs&#39;) q&#39; &#8743; accept q&#39; &#8743; length as &#8804; sg &#8743;
    length bs&#39; &#8804; sg * output_speed&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ass</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ass = length ` {as. &#8707;bs q&#39;. q &#8605;(as, bs) q&#39; &#8743; accept q&#39;}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ass &#8800; {}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ass_def</span><span> </span><span>active_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Inf ass &#8712; ass&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Inf_nat_def1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>q&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>wit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;accept q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as = Inf ass&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ass_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Inf ass &#8804; sg&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>finite_Q</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ass_def</span><span> </span><span>sg_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>output_speed_computation</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wit</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult.commute</span><span> </span><span>order_subst1</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>as</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>bs</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>q&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>active_dest</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;active q bs&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;as bs&#39; q&#39;. q &#8605;(as, bs @ bs&#39;) q&#39; &#8743; accept q&#39; &#8743;
    length bs&#39; &#8804; (1 + sg) * output_speed&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span>bs&#39;</span><span> </span><span>q&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>act</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs @ bs&#39;) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;accept q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>active_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bs&#39; &#8805; output_speed&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs @ bs&#39; = (bs @ take output_speed bs&#39;) @ (drop output_speed bs&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q&#39;&#39;</span><span> </span><span>as&#39;</span><span> </span><span>as&#39;&#39;</span><span> </span><span>cs</span><span> </span><span>cs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#8605;(as&#39;, cs)q&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#39;&#8605;(as&#39;&#39;, cs&#39;)q&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;as = as&#39; @ as&#39;&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(bs @ take output_speed bs&#39;) @ drop output_speed bs&#39; = cs @ cs&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;length cs &#8804; length (bs @ take output_speed bs&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;length (bs @ take output_speed bs&#39;) - length cs &#8804; output_speed&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_split_out</span><span class="delimiter">[</span><span>OF</span><span> </span><span>act</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>app</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ds</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ds_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cs = bs @ ds&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length ds &#8804; output_speed&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span class="delimiter">(</span><span>5</span><span class="delimiter">,</span><span>6</span><span class="delimiter">)</span><span> </span><span>True</span><span> </span><span>split_app</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>app</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>q&#39;&#39;_Q</span><span> </span><span class="delimiter">=</span><span> </span><span>comp_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>act_q&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;active q&#39;&#39; []&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>act</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>active_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>es</span><span> </span><span>fs</span><span> </span><span>q&#39;&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>es_fs_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#39;&#8605;(es, fs)q&#39;&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;accept q&#39;&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length es &#8804; sg&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>active_Nil_dest_sg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>act_q&#39;&#39;</span><span> </span><span>q&#39;&#39;_Q</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fs_len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length fs &#8804; sg * output_speed&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>output_speed_computation</span><span class="delimiter">[</span><span>OF</span><span> </span><span>es_fs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>q&#39;&#39;_Q</span><span class="delimiter">]</span><span> </span><span>es_fs_def</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>dual_order.trans</span><span> </span><span>mult_le_mono1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ds_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>es_fs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>ds_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>fs_len</span><span> </span><span>es_fs_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bounded_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K &#8804; K&#39; &#10233; bounded K &#10233; bounded K&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bounded_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bounded_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;q q&#39; u v v&#39;. bounded K &#10233; init &#8605;(u, v @ v&#39;) q &#10233; active q [] &#10233;
  init &#8605;(u, v) q&#39; &#10233; active q&#39; v&#39; &#10233; length v&#39; &#8804; K&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bounded_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* NFT with trailing bound K *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>bNFT</span><span> </span><span class="delimiter">=</span><span> </span><span>NFT</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a :: finite &#8658; &#39;s &#215; (&#39;b :: finite) list &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>K</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bounded</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bounded K&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>bounded&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>bounded_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bounded</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Definition 3 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>fNFT</span><span> </span><span class="delimiter">=</span><span> </span><span>NFT</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a :: finite &#8658; &#39;s &#215; (&#39;b :: finite) list &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>functional</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x, y) &#8712; &#964; &#10233; (x, y&#39;) &#8712; &#964; &#10233; y = y&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>

</div>
</body>
</html>
